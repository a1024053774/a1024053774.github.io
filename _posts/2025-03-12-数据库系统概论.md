---
layout:       post
title:        "数据库系统概论"
subtitle: '章节课后题笔记'
author:       "LuckyE"
header-style: text
catalog:      true
tags:
    - 数据库系统概论
---
# 数据库系统概论

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image.png)

# 第一章 绪论

## **1.**文件系统与数据库系统区别

最主要的区别：整体数据的结构化
                 数据本身是结构化的，整体数据也是结构化的

### 1. **数据组织方式**

- **文件系统**：以文件和目录的层次结构存储数据，数据间关联较弱，需手动维护。
- **数据库系统**：以结构化表（行与列）组织数据，支持关系模型（如主键、外键），通过模式（Schema）定义数据关系，减少冗余。

### 2. **数据访问与操作**

- **文件系统**：通过路径和文件名访问
- **数据库系统**：通过SQL等查询语言进行复杂操作（如JOIN、聚合），支持事务（ACID）和索引优化，提升查询效率。

### 3. **一致性与事务**

- **文件系统**：无内置事务机制，中断可能导致数据不一致（如写入中途崩溃）。
- **数据库系统**：提供ACID事务支持（原子性、一致性、隔离性、持久性），确保操作完整性和故障恢复。

### 4. **安全与权限管理**

- **文件系统**：基础权限控制（如读写执行），基于用户/组管理。
- **数据库系统**：细粒度权限（如表、列级访问），支持角色管理和审计功能。

### 5. **并发与扩展性**

- **文件系统**：并发控制有限（如文件锁），多用户同时修改易冲突。
- **数据库系统**：内置并发机制（如锁、MVCC），支持高并发读写和分布式扩展。

### 6. **冗余与完整性**

- **文件系统**：易产生数据冗余（如重复文件），需人工维护一致性。
- **数据库系统**：通过范式设计减少冗余，约束（如唯一性、外键）保障数据完整性。

### 7. **应用场景**

- **文件系统**：适合存储非结构化数据（文档、媒体）或简单配置。
- **数据库系统**：适用于结构化数据（用户信息、交易记录），需复杂查询和事务的场景。

### 示例对比

- **存储图片**：文件系统直接存储图片文件，数据库存储路径或元数据。
- **用户管理**：数据库用表存储用户ID、姓名，关联订单表；文件系统需多个文件手动关联。

### 总结

文件系统提供基础存储，灵活但功能有限；数据库系统通过结构化管理和高级功能，适合复杂数据操作。两者常结合使用（如数据库底层依赖文件系统），但核心定位不同。

## 2.数据，数据库，数据库管理系统，数据库系统的概念

1. **数据**

   数据的定义：描述事物的符号记录

   数据的种类：文本、图形、图像、音频、视频

   语义：数据的含义

   **数据👉20180002，刘晨，女，1999-9-1，计算机**

   **语义👉学号、姓名、性别、出生日期、主修专业**
2. **数据库**
   **长期储存**在计算机内**有组织**、**可共享**的大量数据的集合
   **数据库的基本特征**
   有组织：    **数据按一定的数据模型组织、描述和储存**可共享：    **较小的冗余度**较高的数据独立性
   可扩展性
3. **数据库管理系统**
   位于用户与操作系统之间的一层数据管理**软件
   *第5题：主要功能：***
   ①数据定义功能
   提供数据定义语言（DDL） data definition language，定义数据库中的数据对象的组成与结构

②数据组织、存储和管理功能
       分类组织、存储和管理各种数据，确定组织数据的文件结构和存取方式，提供多种存取方法（索引查找/哈希查找/顺序查找）提高存取效率

③数据操纵功能
       提供数据操纵语言（DML） data manipulation language，实现对数据库的基本操作  （查询、插入、删除和修改）

④数据库的事务管理和运行管理功能
       数据库在建立、运行和维护时由数据库管理系统统一管理和控制,保证数据的安全，完整性和多用户对数据的并发使用及发生故障后的系统恢复

⑤数据库的建立和维护功能功能
      数据库初始数据的输入和转换，数据库转储和恢复功能，数据库的重组织、性能监视和数据分析等

⑥其他功能功能
数据库管理系统与网络中其他软件系统的通信
数据库管理系统系统之间或与文件系统的数据转换
异构数据库之间的互访和互操作
4. **数据库系统**     **database system，简称DBS**
**数据库系统的构成：数据库，数据库管理系统（及外围的应用开发工具），应用程序，数据库管理员**

DBS指  引入数据库后的**计算机系统**

---

    ![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%201.png)

## 3.分别举出适合用文件系统的，和适合数据库系统的应用例子

### **适合文件系统的应用场景**

文件系统适合存储 **非结构化数据** 或需要直接访问原始文件的场景，通常**对复杂查询和事务要求较低**。

### **1. 多媒体文件存储**

### **2. 日志文件**

### **3. 文档和配置文件**

---

### **适合数据库系统的应用场景**

数据库系统适合需要 **结构化数据管理**、复杂查询、**事务**支持和**高并发**的场景。

### **1. 用户管理系统**

- **例子**：用户注册、登录、权限管理。
- **原因**：需通过 SQL 查询用户信息（如 `SELECT * FROM users WHERE email='xxx'`），事务保证注册操作的原子性，外键关联角色表。

### **2. 电商平台**

- **例子**：商品库存、订单管理、支付流水。
- **原因**：需处理**高并发**下单（事务保证库存扣减与订单生成一致），支持复杂查询（如统计某商品的月销量）。

### **3. 金融系统**

- **例子**：银行账户余额、转账记录。
- **原因**：ACID **事务**确保转账操作的原子性（如 A 扣款与 B 到账必须同时成功），数据一致性要求极高。

### **4. 社交网络**

- **例子**：用户关系（关注/粉丝）、动态消息、评论。
- **原因**：需通过**关系型数据库**的表关联（如 `JOIN`）查询好友动态，索引加速搜索。

---

### **混合使用场景**

实际应用中，文件系统和数据库系统常结合使用：

- **例子**：网盘服务
  - **数据库**：存储文件的元数据（名称、大小、路径、所有者）。
  - **文件系统**：存储实际的文件内容（如用户上传的文档、视频）。
- **例子**：医疗影像系统
  - **数据库**：记录患者信息、诊断报告。
  - **文件系统**：存储 CT、MRI 等大型医学影像文件。

---

### **总结**

- **文件系统**：适合直接存储文件、非结构化数据、简单读写场景。
- **数据库系统**：适合结构化数据、复杂查询、事务和高并发场景。
- **混合架构**：结合两者优势，数据库管理元数据，文件系统存储大文件。

## 4.数据库系统的特点

**特点：**
**（1）整体数据的结构化：**
数据本身是结构化的，整体数据也是结构化的
1.把数据结构的定义从应用程序中分离出来
2.用关系数据库语言SQL，对数据库curd操作简单，提高编写应用程序的效率。

**（2）数据的共享性强，冗余度低且易于扩充**
数据共享性可以降低数据的冗余度, 节省存储空间 还能避免数据的不相容性与不一致性。
`所谓数据的不一致性, 是指同一数据不同副本的值不一样。 采用人工管理或文件系统管理而时, 由于数据被重复存储在数据库中数据共享则减少了由数据冗余造成的不一致现象。`

`数据库数据的共享性强还使其易于增加新的应用, 易于扩充 这也是数据库系统"弹性大"的原因。当应用需求改变或增加时, 只要重新选取不同的子集或加上一部分数据即可满足新的需求。`
**（3）数据的独立性强**
数据的独立性强是数据库数据的一个显著优点,目标是应用程序与数据（定义）相分离。
`数据的物理独立性, 是指用户的应用程序与数据库中数据的物理存储是相互独立的。也就是说, 数据在数据库中怎样存储是由数据库管理系统管理的,用户程序不需要了解, 这样当数据的物理存儲改变时应用程序不用改变。

数据的逻輯独立性, 是指用户的应用程序与数据库的逻輯结构是相互独立的。也就是说,数据的逻辑结构改变时用户程序也可以不变。`
数据的独立性把数据的定义从应用程序中分离出去,而存取数据的方法又由数据库管理系统负责提供, 从而简化了应用程序的编制, 大大减少了应用程序的维护和修改工作。
**（4）数据由数据库管理系统统一管理和控制**
              1. 数据的安全性保护：保护数据，阻止不合法使用
              2.数据的完整性检查：将数据控制在有效的范围内
              3.数据的并发性控制：保证用户事务的执行不受其他事务干扰
              4.数据库的恢复：从错误状态恢复到正确状态
              ****

数据库是长期存储在计算机内的有组织、可共享的大量数据的集合。它可以供各种用户共享,具有最小的冗余度和较强的数据独立性。数据库管理系统在数据库建立、运维时对数据库进行统一控制,以保证数据的完整性和安全性, 并在多用户同时使用数据库时进行并发控制,在发生故障后对数据库进行恢复。

## 5.数据库管理系统的主要功能

***主要功能：***
①数据定义功能
       提供数据定义语言（DDL） data definition language，定义数据库中的数据对象的组成与结构

②数据组织、存储和管理功能
       分类组织、存储和管理各种数据，确定组织数据的文件结构和存取方式，提供多种存取方法（索引查找/哈希查找/顺序查找）提高存取效率

③数据操纵功能
       提供数据操纵语言（DML） data manipulation language，实现对数据库的基本操作  （查询、插入、删除和修改）

④数据库的事务管理和运行管理功能
       数据库在建立、运行和维护时由数据库管理系统统一管理和控制,保证数据的安全，完整性和多用户对数据的并发使用及发生故障后的系统恢复

⑤数据库的建立和维护功能功能
      数据库初始数据的输入和转换，数据库转储和恢复功能，数据库的重组织、性能监视和数据分析等

⑥其他功能功能
数据库管理系统与网络中其他软件系统的通信
数据库管理系统系统之间或与文件系统的数据转换
异构数据库之间的互访和互操作

## 6.什么是概念模型？作用是什么？

**数据建模**：把现实世界中的具体事物抽象、组织为某一数据库管理系统支持的数据模型

**数据建模过程——两步抽象**

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%202.png)

**1.现实世界中的客观对象抽象为概念模型(如E-R图）——将现实世界抽象为信息世界**

**2.把概念模型转换为某一数据库管理系统支持的数据模型（如各种表）——将信息世界转换为机器世界**

### 概念模型是什么？

·是现实世界到机器世界的一个中间层次，是现实世界到信息世界的第一层抽象

### 作用是什么？

用于信息世界的建模

数据库设计的有力工具

数据库设计人员和用户之间进行交流的语言

### 概念模型的一种表示方法：实体-联系模型   实体-联系方法（Entity-Relationship Approach）用E-R图来描述现实世界的概念模型

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%203.png)

**抽象了学校中的学生和课程两个客观事物：学生实体和课程实体**

**抽象了现实世界中事物之间的联系：**

**一门课程可以有多名学生选修，一个学生可以选修多门课程**

**用课程实体与学生实体多对多（m:n）联系来描述**

## 7.概念模型中的术语

### 实体entity

客观存在并可相互区别的事物称为**实体。**    `如一个员工，一个学生，一个部门`

### 属性attribute

实体所具有的某一特性称为属性，一个实体可以由若干个属性来刻画。  `如学号，性别，出生日期`

### 码key

实体的唯一标识 `如学号，身份证号`

### 实体类型entity type

用**实体名及其属性名集合**来抽象和刻画同类实体称为**实体类型**   `如：学生（学号，姓名，年龄，出生日期）`

### 实体集entity set

同一类型实体的集合称为实体集。  `如：全体学生`

### 联系relationship

反映实体内部与之间的联系

*实体内部的联系通常是指组成实体的各属性之间的联系

*实体之间的联系通常是指不同实体集之间的联系

实体之间的联系有一对一、一对多和多对多类型

## 8.数据模型的概念，作用，以及三要素

**数据模型**是对现实世界数据特征的抽象表示（逻辑上的），用于描述数据的结构、关系、约束和操作规则。
**作用：**是数据库系统的核心，帮助组织、存储和管理数据，确保数据的一致性、有效性和可操作性。

**三要素：
1.数据结构**
描述数据库的组成对象以及对象之间的联系
描述的内容
    ①与对象的类型、内容、性质有关
    ②与数据之间联系有关
**数据结构是对系统静态特性的描述**

**2.数据操纵**
对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则
**数据库主要操作**
①查询
②更新（包括插入、删除、修改）
**数据操纵是对系统动态特性的描述

3.完整性约束**
一组完整性规则
          **`完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则`**
作用：    **限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容**

## 9.层次模型的概念，以及三个实例

`如：树`**层次模型用树形结构来表示各类实体以及实体间的联系**
***实体用记录表示
*实体的属性对应记录的数据项（或字段）
*实体之间的联系转换成记录之间的两两联系**
***数据结构的单位是基本层次联系
—————是指两个记录以及它们之间的一对多（包括一对一）的联系**

层次模型以**树形结构**组织数据，每个节点（除根节点外）仅有一个父节点，支持**一对多**关系。

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%204.png)

![层次模型的数据结构](image%205.png)

层次模型的数据结构

**要求：**

1. **有且只有一个**结点没有双亲结点，这个结点称为**根结点**
2. 根以外的**其他结点**有且**只有一个双亲结点**

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%206.png)

**例子 1：文件系统**

```jsx
**结构**：目录（父节点）包含子目录和文件（子节点），形成严格的树形层级。
**特点**：每个文件/目录仅属于一个父目录，例如：
/根目录  
  ├── Documents/  
  │   ├── Report.docx  
  │   └── Budget.xlsx  
  └── Photos/  
      ├── Holiday.jpg  
      └── Family.jpg  
```

**例子 2：公司组织结构**

```jsx
**结构**：部门与子部门的层级划分，如：
公司总部  
  ├── 技术部  
  │   ├── 开发组  
  │   └── 测试组  
  └── 市场部  
      ├── 广告组  
      └── 销售组  
• **特点**：每个子部门仅隶属于一个上级部门。
```

**例子 3：生物分类学（Linnaean分类法）**

```jsx
**结构：**生物分类的层级体系（界→门→纲→目→科→属→种），例如：
动物界  
  └── 脊索动物门  
      └── 哺乳纲  
          └── 食肉目  
              └── 猫科  
                  └── 猫属  
                      └── 家猫（种）
**特点：**严格的单父节点层级关系。  
```

## 10.网状模型的概念，以及三个实例

网状数据库系统采用**网状模型**作为数据的组织方式

**满足下面两个条件的基本层次联系集合：**

1. **允许一个以上的结点无双亲(多个根节点）**
2. **一个结点可以有多于一个的双亲**

网状模型以**图结构**组织数据，允许节点有**多个父节点**，支持**多对多**关系。

**网状模型可以更直接地描述现实世界
           层次模型实际上是网状模型的一个特例
网状模型中子女结点与双亲结点的联系可以不唯一
          要为每个联系命名，并指出与该联系有关的双亲记录和子女记录**

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%207.png)

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%208.png)

**例子 1：CODASYL数据库（如IDMS）**

```jsx
**结构**：学生选课场景中，学生、课程、教师之间的关系：
一个学生可选多门课程，一门课程可由多个学生选修。
一门课程可由多名教师教授，一名教师可教授多门课程。
**特点**：通过“指针”直接链接相关记录，例如：
学生（张三） → 选修 → 课程（数据库）  
                   ↑  
教师（李四） → 教授  
```

**例子 2：城市交通网络**

```jsx
**结构：**交叉路口与道路连接，例如：
交叉口A  
  → 道路1 → 交叉口B  
  → 道路2 → 交叉口C  
交叉口B  
  → 道路3 → 交叉口C  
 **特点**：一个交叉口可连接多条道路，形成复杂的网状拓扑。
```

**例子 3：供应链管理**

```jsx
**结构：**供应商、产品、工厂之间的多对多依赖关系：

供应商A为工厂X和Y提供原材料。

工厂X生产产品P和Q，产品P由供应商A和B共同供货。

**特点：**通过网状路径追踪物料流动，例如：
供应商A → 供应 → 工厂X → 生产 → 产品P  
                          ↑  
供应商B → 供应 ────────────┘  
```

## 11.网状数据库，层次数据库的优缺点

### **层次模型的优缺点**

**优点**

1.层次模型的数据结构比较简单清晰

2.查询效率高 `层次模型中记录之间的联系用有向边表示，就是记录之间的存取路径`

3.层次数据模型提供了良好的完整性约束支持

**缺点**

1.很多联系是非层次性，不适合用层次模型表示

2.一个结点具有多个双亲结点，只能通过冗余数据（易产生不一致性）或创建非自然的数据结构（虚拟结点）来解决

3.对插入和删除操作的限制多，应用程序的编写比较复杂

4.查询子女结点必须通过双亲结点

5.层次命令趋于程序化

### 网状模型的优缺点

**优点**

1.能够更直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系

2.具有良好的性能，存取效率较高

**缺点**

1.结构比较复杂，随着应用环境的扩大，数据库结构就变得越来越复杂，不利于最终用户掌握

2.DDL、DML语言复杂，要嵌入某一种高级语言中，用户不容易使用

3.记录之间联系是通过存取路径实现，用户必须了解系统结构的细节

## 12.关系模型的概念，以及术语

**关系数据库系统采用关系模型作为数据的组织方式**

    **每个关系的数据结构是一张规范化的二维表**

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%209.png)

关系relation：一张二维表

元组tuple：一行

属性：一列，每列的名称成为属性名

码：一个或一组属性。可唯一确定一个元组

域domain：某一属性的取值范围。`如性别的域是（男，女）`

分量component：元组中的一个属性值。`如李勇`

关系模式：对关系的描述。类似于实体类型
          关系名（属性1，属性2，…，属性n）`如 学生（学号 ，姓名，性别，出生日期，主修）`

    关系必须是规范化的，满足一定的规范条件

    最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表

    表1.3中联系方式是可分的数据项，不符合关系模型要求

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2010.png)

---

**关系术语                      与                    现实生活                          对比**

| **关系术语**   | **一般表格的术语**             |
| -------------------- | ------------------------------------ |
| **关系名**     | **表名**                       |
| **关系模式**   | **表头（表格的描述）**         |
| **关系**       | **（一张）二维表**             |
| **元组**       | **记录或行**                   |
| **属性**       | **列**                         |
| **属性名**     | **列名**                       |
| **属性值**     | **列值**                       |
| **分量**       | **一条记录中的一个列值**       |
| **非规范关系** | **表中有表（大表中嵌有小表）** |

## 13.关系模型的优缺点

**优点**

1.建立在严格的数学概念的基础上

2.概念单一

实体和实体之间联系都用关系来表示

对数据的检索和更新结果也是关系

**3**.关系模型的存取路径对用户是隐蔽的

具有更高的数据独立性，更好的安全保密性

简化了程序员的工作和数据库开发建立的工作

**缺点**

1.存取路径对用户隐蔽，查询效率往往不如层次模型和网状模型

2.为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的难度

### **数据库技术的发展是沿着数据模型的主线推进的。**

计算机数据模型应该满足的**要求：**
尽量真实地模拟世界、便于在计算机上实现.

## 14.数据库系统的三级模式结构以及这种结构的优点

    **从数据库管理系统角度看**   **三级模式结构，`模式，内模式，外模式`    是数据库系统内部的体系结构**

 **根据计算机的系统结构，从数据库最终用户角度看，数据库系统的外部体系结构分为:**

**`集中式结构`**

**`客户机/服务器（浏览器/应用服务器/数据库服务器）`**

**`并行结构`**

**`分布式结构`**

**`云结构`**

### **模式的概念**

数据模型中有 `类型(型)`和 `值` 的概念。

型type是指       **某一类数据的结构和属性的说明**                                   “学生”记录类型：**`学生（学号，姓名，性别，出生日期，主修专业）`**

值value是指         **型的一个具体赋值**                                                               记录值：**`（20180003，王敏，女，2001-8-1，计算机科学与技术）`**

模式schema 也称逻辑模式。

是数据库中**全体数据**的逻辑结构和特征的描述，不涉及具体的值。

反映的是数据的结构及其联系

 模式是相对稳定的

实例instance

模式的一个具体的值

反映数据库某一时刻的状态

同一个模式可以有很多实例

实例随数据库中数据的更新而变动

### 三级模式结构

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2011.png)

**模式（schema）**    **也称逻辑模式**

1.数据库中全体数据的逻辑结构和特征的描述，所有用户的**公共数据视图**。

2.**一个数据库只有一个模式**

3.**模式的地位**：是数据库系统模式结构的**中间层**

与数据的物理存储细节和硬件环境无关

与具体的应用程序、开发工具及高级程序设计语言无关

4.**数据库管理系统提供模式数据定义语言（模式DDL）来严格地定义模式**

**外模式（external schema）**         **也称** **子模式或用户模式**

 1.数据库用户（包括应用程序员和最终用户）能够看见和使用的**局部数据**的逻辑结构和特征的**描述**

**2.一个数据库可以有多个外模式**

不同在用户的应用需求、看待数据的方式、对数据保密的要求等方面存在差异

3.**同一外模式也可以为某一用户的多个应用系统所使用，但**一个应用程序只能使用一个外模式

4.**外模式的用途**

保证数据库安全性的一个有力措施

每个用户只能看见和访问所对应的外模式中的数据

5.**数据库管理系统提供外模式数据定义语言（外模式DDL）来严格地定义外模式。**

`CREATE **VIEW** Is_Student AS SELECT Sno,Sname FROM Student WHERE …`

**内模式（internal schema）**      **也称物理模式或存储模式**

1.是**数据物理结构**和**组织方式**的描述

2.**数据**在数据库**内部**的**表示方式 ←—————**与具体的物理设备无关

    记录的存储方式(升降序，堆存储…)
    索引的组织方式（B+树，hash索引）
     数据是否压缩，加密

## 15.解释数据与程序的物理独立性和逻辑独立性。以及为什么数据库系统具有较强的数据与程序独立性？

**两级映象在数据库管理系统内部实现三个抽象层次的联系和转换**

### 逻辑独立性：

由于 **外模式/模式** 映像

    **模式**：描述的是数据的**全局**逻辑结构

**外模式**：描述的是数据的**局部**逻辑结构

🎗️同一个模式可以有任意多个外模式

**每一个外模式**，数据库系统**都有一个外模式／模式映像**，定义外模式与模式之间的对应关系

**映象定义**通常**包含在各自外模式**的描述中

**保证数据的逻辑独立性**

  当**模式改变时**，数据库管理员对外模式／模式**映象作相应改变**，使**外模式保持不变**

  应用程序是依据数据的外模式编写的，**应用程序不必修改**，**保证了**数据与程序的**逻辑独立性**，简称数据的逻辑独立性

### 物理独立性：

由于    **模式／内模式**  映像

模式／内模式映象定义了数据**全局逻辑结构**与**存储结构**之间的对应关系。

`例如，说明逻辑记录和字段在内部是如何表示的`

数据库中模式／内模式映象是唯一的

该映象定义通常包含在模式描述中

**保证数据的物理独立性**

  ****当数据库的**存储结构改变时**（例如选用了另一种存储结构），数据库管理员**修改模式／内模式映象**，使**模式保持不变**

  模式保持不变，**应用程序不必改变**。**保证了**数据与程序的**物理独立性**，简称数据的物理独立性。

### 小结

数据库模式（即全局逻辑结构)，是数据库的中心与关键，**独立于**数据库的其他层次。设计数据库模式结构时应**首先确定**数据库的**逻辑模式**

**数据库的内模式**

依赖于它的全局逻辑结构

独立于数据库的用户视图，即外模式

独立于具体的存储设备

将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率

**数据库的外模式**

面向具体的应用程序

定义在逻辑模式之上

独立于存储模式和存储设备

当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动

设计外模式时应充分考虑到应用的扩充性

**特定的应用程序**

在外模式描述的数据结构上编制的

依赖于特定的外模式

与数据库的模式和存储结构独立

不同的应用程序有时可以共用同一个外模式

### 为什么具有较强的独立性？

**数据库的二级映像**

保证了数据库外模式的稳定性

从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改

### **数据与程序之间的独立性的作用？**

    使得数据的定义和描述可以从应用程序中分离出去

数据的存取由数据库管理系统管理

简化了应用程序的编制

大大减少了应用程序的开发和维护成本

## 16.数据库系统的组成

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2012.png)

1. **数据库**  存放在存储设备中
2. **数据库管理系统（及其应用开发工具）**   为数据库系统开发提供软件生态环境
3. **应用系统**      支持数据库管理系统运行的操作系统，应用开发工具，为特定应用背景开发的数据库应用系统
4. **数据库管理员**

   ①设计与定义数据库
   ②帮助最终用户使用数据库系统

   ③负责数据库系统的运维工作

   ④改进和重组数据库系统，调优数据库系统的性能

   ⑤转储与恢复数据库

   ⑥重构数据库

# 第二章 关系模型

## 1.试述关系模型的三个组成部分。

关系模型由

1. 关系数据结构
2. 关系操作集合
3. 关系完整性约束

三部分组成。

## 2.简述关系数据语言的特点和分类。

![1000038522.jpg](1000038522.jpg)

1. 关系代数语言
   用对关系的运算来表达查询要求
2. 关系演算语言：用谓词来表达查询要求
   a. 元组关系演算语言
   谓词变元的基本对象是元组变量
   b. 域关系演算语言
   谓词变元的基本对象是域变量
3. 具有关系代数和关系演算双重特点的语言
   代表： SQL （ Structured Query Language ）

共同特点是

1. 语言具有完备的表达能力
2. 是非过程化的集合操作语言，功能强
3. 能够嵌入高级语言中使用。

## 3.定义并理解下列术语, 说明它们之间的联系与区别：

### 域, 笛卡儿积, 关系, 元组, 属性;

1. 域（ Domain ）
   一组具有**相同数据类型**的**值**的**集合**
   例子：整数，实数，{‘ 男’，‘女’ }
2. 笛卡尔积（ Cartesian Product ）
   域上的一种集合运算，所有域的**所有取值**的一个**组合
   不能重复**

   ![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2013.png)

   ![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2014.png)

*基数为2*2*3=12*

1. **关系（ Relation ）**
   D1×D2×…×Dn的**子集，**表示为**R （ D1， D2，…， Dn）**
   R ：关系名     n ：关系的目或度（ Degree ）
   **属性有几个，就是几目关系**
   **单元关系（ Unary relation ）**
   当 n=1 时，称该关系为单元关系。单**目**关系
   **二元关系（ Binary relation ）**
   当 n=2 时，称该关系为二元关系,二目关系

**表**的**每行**对应**一个元组**，表的**每列**对应**一个域(属性)**
2. **元组（ Tuple ）**
   笛卡尔积中**每一个元素**叫作一个 n 元
        组（ n-tuple ）或简称**元组 (Tuple)**
                 ( 张清玫，计算机专业，李勇 )
                 ****( 张清玫，计算机专业，刘晨 )
   **分量（ Component ）**
       元组中的**每一个字段**都是分量
   **基数（ Cardinal number ）**
       一个域中的  **不同取值个数**
      笛卡尔积之后的基数为**每个相乘域的基数之积**
3. **属性（attribute）**
n 目关系必有 n 个属性

### 主码,全码,候选码, 外码, 主属性、非主属性;

1. 主码（ Primary key ）
   一个关系有多个候选码，则**选**定其中**一个**为**主码**
2. 全码（ All-key ）
   最极端的情况：关系模式的**所有属性组是**这个关系模式的
   **候选码**
3. 候选码（ Candidate key ）
   **关系中** 某一属性**组** 的值能**⭐唯一地标识⭐**一个元组
   简单的情况：候选码只包含一个属性
4. 外码（ Foreign Key）
   **F**是基本关系R的一个或一组**属性，**但**不是**关系**R的
   码**。基本关系S中的主码Ks与F对应，那么F是R的***外码***
   也就是**F是S的主码**，同时**是R的一个属性(非码)**
   R称为**参照关系**（Referencing Relation ）非码
   ****S称为**被参照关系**（Referenced Relation ）主码
   或目标关系（Target Relation）
   *非码参照了主码*
5. 主属性（Prime attribute）
   **候选码里的**属性
6. 非主属性（ Non-Prime attribute）
   **不包含**在任何**侯选码中**的属性

### 关系模式, 关系, 关系数据库

1. **关系（ Relation）
   a.定义：**关系是元组的集合，**是值**
   b.**关系的表示**
   关系也是一个二维表，表的每行对应一个元组，表的每
   列对应一个域
   c.取出**有实际意义的元组**来**构造关系**
   关系： SAP(SUPERVISOR ， SPECIALITY ， POSTGRADUATE)
   d.**三类关系**
   基本关系（基本表或基表）
   实际存在的表，是实际存储数据的逻辑表示
   ****查询表
   查询结果对应的表
   视图表
   由基本表或其他视图表**导出的表**，是**虚表**，**不对
   应**实际存储的数据
   e.基本关系的性质
   **①** 列是**同质**的（Homogeneous）**同一个域
   ②** 不同的列可出自同一个域
   如：研究生，导师都是人，都放在人的域里面
   但是在研究生-导师关系表中，
   Ⅰ.**不同的属性**要给予**不同的属性名**
   Ⅱ.其中的**每一列**称为**一个属性**
   ③列的次序可以任意交换
   ④任意两个元组的候选码不能相同(唯一标识)
   ⑤行的次序可以任意交换
   ⑥分量必须取原子值（最基本的一条）

   ![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2015.png)
2. **关系模式（Relation Schema）是型**
   关系模式是对关系的**描述
   a.**关系模式可以形式化地表示为：
   ****    **R（ U， D， DOM， F）**
   R :关系名
   U :组成该关系的**属性名集合**
   D :属性组**U中属性**所**来自的域**
   DOM :属性向域的映象集合
   导师和研究生出自同一个域——人
   取不同的属性名，并在模式中定义属性向域
   的映象，即说明它们分别出自哪个域：
   DOM（SUPERVISOR-PERSON ）
   = DOM（POSTGRADUATE-PERSON ）
   =PERSON
   F :属性间的数据依赖关系集合
   b.关系模式通常可以简记为R (U)或R (属性1， 属性2，…)
3. **关系数据库**
   a. **所有关系的集合(所有的表)**构成一个关系数据库
   支持关系模型的**数据库系统**称为**关系数据库系统**
   b.关系数据库的型与值
   关系数据库的**型**:关系数据库模式对关系数据库的**描述**。
   关系数据库模式包括:
   若干**域的定义**
   在这些**域上定义的**若干**关系模式**
   关系数据库的**值**:
   关系模式在某一时刻对应的**关系的集合**，简称为关系   数据库

---

## 4.举例说明关系模式和关系的区别。

关系模式与关系**区别**：
       关系模式：对关系的描述，静态的、稳定的
       关系：关系模式在某一时刻的状态或内容，动态的，   变化的
*关系模式和关系往往统称为关系*

## 5.试述关系模型的完整性约束。 在参照完整性中, 什么情况下外码属性的值可以为空值？

实体完整性和参照完整性：**必须**
关系模型**必须满足**的完整性约束条件
称为关系的两个**不变性**，应该由关系系统自动支持

用户定义的完整性：
应用领域需要遵循的约束条件，体现了具体领域中的
语义约束

### 实体完整性 （ Entity Integrity）**必须**

(1) 实体完整性规则是**针对基本关系**而言的。一个基本表通常对应现实世界的一个实体集。
(2) 现实世界中的实体是**可区分**的，即它们具有某种唯一性标识。如：学生都有唯一的学号
(3) 关系模型中以主码作为**唯一性标识。**
(4) 主码中的属性即**主属性不能取空值**。否则与（2）矛盾

### 参照完整性（referential integrity）**必须**

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2016.png)

```xml
学生、课程、学生与课程之间的**多对多**联系
学生（*学号*，姓名，性别，专业号，年龄）
课程（*课程号*，课程名，学分）
选修（*学号，课程号*，成绩） 
“学号”和“课程号”是选修关系的**外码**
学生关系和课程关系**均为被参照关系**
选修关系为**参照关系**

学生实体及其内部的**一对多**联系
学生（*学号*，姓名，性别，专业号，年龄，*班长*）
*学号* 姓名 性别 专业号 年龄 *班长*
801 张三 女   01    19   
802 李四 男   01    20   802
803 王五 男   01    20   
804 赵六 女   02    20   
805 钱七 男   02    19   805
学号”是**主码**，“班长”是**外码**，它引用了本关系的“学号”
班长” 必须是**确实存在**的学生的学号

*“班长”与本身的主码“学号”相对应，“班长”是外码
学生关系**既是**参照关系**也是**被参照关系
见下图：*
```

![多对多](image%2017.png)

多对多

![一对多](image%2018.png)

一对多

**外码特点总结：⭐⭐⭐**
1.关系R和S不一定是不同的关系，如**一对多⭐
2.**目标关系S的主码Ks 和参照关系的外码F必须定义在同
一个（或一组）域上**⭐**
3.当外码与相应的主码属于不同关系时，往往取相同的名
字，以便于识别
但是，外码并**不一定**要与相应的主码同名**⭐**
                  如:学生（学号，主修专业)
                        专业（专业名，专业编号）
`专业名是专业关系中的主码，主修专业是学生关系中的外码，这两个是同样的域，但是名字不一样`
4.外码的取值**必须**：
①取空值（每个属性值均为空值）
②等于主码值
属性在被参照关系中不是主属性，则可以取空值，否则不能取空值。

```xml

*例*1.学生关系中每个元组的“专业号”属性只取两类值：
（1）空值，表示尚未给该学生分配专业
（2）非空值，必须是专业中某个元组的“专业号”值 
例2.选修（学号，课程号，成绩）
“学号”和“课程号”可能的取值 ：
（1）选修关系中的主属性，不能取空值
（2）只能取相应被参照关系中**已经存在**的主码值
例3.学生（学号，姓名，性别，专业号，年龄，班长）
“班长”属性值可以取两类值：
（1）空值，表示该学生所在班级尚未选出班长
（2）非空值，该值必须是本关系中某个元组的学号值
```

### 用户定义的完整性   应该提供

**针对**某一**具体关系**数据库**的约束条件
如：性别只可以填 `男，女`**

## 6.试述等值连接与自然连接的区别和联系

**连接运算符**是“=”的连接运算称为等值连接。从关系R与S的广义笛卡尔积中选取A，B属性值相等的那些元组。

**自然连接**是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。

## 7.关系代数的基本运算有哪些？如何用这些基本运算来表示其他运算？

| **集合运算符**          | 含义     |
| ----------------------------- | -------- |
| ∪                            | 并       |
| -                             | 差       |
| 如：R - S，元组属于R，不属于S |          |
| ∩                            | 交       |
| ×                            | 笛卡尔积 |

| **比较运算符** | 含义     |
| -------------------- | -------- |
| ＞                   | 大于     |
| ≥                   | 大于等于 |
| ＜                   | 小于     |
| ≤                   | 小于等于 |
| ＝                   | 等于     |
| <>                   | 不等于   |

| **专门的关系运算符** | 含义                                         |
| -------------------------- | -------------------------------------------- |
| σ                         | 选择    选择出符合条件的元组(行)             |
| π                         | 投影    选择出符合条件的列（去除完全相同的） |
| ⋈                         | 连接    等值连接，自然连接                   |
| 自然连接要去掉重复的属性列 |                                              |
| ÷                         | 除                                           |

| 逻辑运算符 | 含义 |
| ---------- | ---- |
| ¬         | 非   |
| ∧         | 与   |
| ∨         | 或   |

并、差、笛卡尔积、投影和选择5种运算为**基本的运算**。

其他3种运算，即交、连接和除，均可以用这5种基本运算来表达。

### 关于连接

**1.外连接（OUTER JOIN）**
把舍弃的元组(悬浮元组)也保存在结果关系中，而在其他属
性上填空值(Null)
2.**左外连接LEFT JOIN**
把左边关系R中要舍弃的元组保留
3.**右外连接 RIGHT JOIN**
把右边关系S中要舍弃的元组保留

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2019.png)

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2020.png)

### **一、交运算（∩）的实现**

**R ∩ S = R - (R - S)
👉**R-S先剔除R中的S，此时结果中没有S，然后再用R - (R - S)，结果中就是R中有的，也是S有的。`因为R中的元组要么S中有，要么没有`

### **二、自然连接运算（⋈）的实现**

| R |   |
| - | - |
| A | B |
| 1 | 2 |
| 3 | 4 |

| S |   |
| - | - |
| B | C |
| 2 | 5 |
| 4 | 6 |

`自然连接`  **去除**重复的列，**选择**出**公有属性相等的行**

 R ⋈ S = π目标属性(σ连接条件(R × S))

**步骤**：

①笛卡尔积 R × S：

| A | R.B | S.B | C |
| - | --- | --- | - |
| 1 | 2   | 2   | 5 |
| 1 | 2   | 4   | 6 |
| 3 | 4   | 2   | 5 |
| 3 | 4   | 4   | 6 |

②选择 R.B = S.B：σR.B=S.B

| A | R.B | S.B | C |
| - | --- | --- | - |
| 1 | 2   | 2   | 5 |
| 3 | 4   | 4   | 6 |

③投影去重：πA,R.B,C

结果：R ⋈ S

| A | R.B | C |
| - | --- | - |
| 1 | 2   | 5 |
| 3 | 4   | 6 |

### **三、除运算（÷）的实现**

### 关于除

用来解决*至少包含几个,学习全部课程…*的这种问题

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2021.png)

R➗S=T ,T**包含所有在R中**但是**不在S中的**属性和值，而且**T的元组和S的元组的所有组合**都在R中

给定关系R (X ，Y) 和S (Y ，Z)，其中X ，Y ，Z 为属性组。

R ÷S👉S中有Y和Z，但是R中只有X,Y ，无Z。

则去除R中没有的**Z**和R与S中都有的**Y** **只保留X，**

得到一个新的关系P(X)
**Y** `可以有不同的属性名`，但是 `必须出自相同的域集。`

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2022.png)

```xml
去除之后，只剩A，则A可取值 **{*a*1 ，a2，a3，a4}
		a1的象集为 {(b1，c2)，(b2，c3)，(b2，c1)}
    a2的象集为 {(b3，c7)，(b2，c3)}
    a3的象集为 {(b4，c6)}
    a4的象集为 {(b6，c6)}
S在(B，C)上的投影为
		{(b1，c2)，(b2，c1)，(b2，c3) }
只有a1的象集包含了S在(B，C)属性组上的投影
     所以 R÷S ={a1}** 
```

# 第三章 SQL语言

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2023.png)

## SQL的基本概念

SQL支持数据库的三级模式结构。

### **基本表**

1. 本身独立存在的表
2. 关系数据库管理系统中一个关系就对应一个基本表
3. 一个或多个基本表对应一个存储文件
4. 一个表可以带若干索引

### **存储文件**

1. 逻辑结构和物理结构组成了关系数据库的内模式
2. 物理文件结构是由数据库管理系统设计确定的

### 视图

1. 从基本表或其他视图中导出的表
2. 数据库中只存放视图的定义而不存放视图对应的数据
3. 视图是一个虚表
4. 用户可以在视图上再定义视图

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2024.png)

## 数据定义

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2025.png)

---

# 课后题

## 1.SQL的特点

1. 综合统一。SQL语言集数据定义语言DDL、数据操纵语言DML、数据控制语言DCL的功能于一体。
2. 数据操纵高度非过程化。只要提出“做什么”，而无需指明“怎么做”，无需了解存取路径，**存取路径的选择**以及**SQL语句的操作过程**由系统自动完成。
3. 面向集合的操作方式。操作对象、查找结果可以**是元组的集合**，而且一次插入、删除、更新操作的对象也可以是元组的集合。
4. 以**同一种语法结构**提供**两种使用方式**。SQL语言**既是独立的语言**，**又是嵌入式语言**。
   作为独立的语言，它能够独立地用于联机交互的使用方式，用户可以直接在终端上输入指令进行操作；
   作为嵌入式语言，它能够嵌入到高级语言程序中，供设计程序时使用。
5. 语言简洁易用
   | SQL功能  | 动词                 |
   | -------- | -------------------- |
   | 数据定义 | CREATE,DROP,ALTER    |
   | 数据查询 | SELECT               |
   | 数据操纵 | INSERT,UPDATE,DELETE |
   | 数据控制 | GRANT,REVOKE         |

## 2.说明在DROP TABLE时，RESTRICT与CASCADE的区别

`DROP TABLE 表名 RESTRICT/CASCADE`

**RESTRICT 删除有限制条件，若存在这些依赖该表的对象，则不能被删除**
 a. 即该表不能被其他表的约束所引用（如CHECK,FOREIGN KEY等约束）
 b.不能有视图
 c.不能有触发器
 d.不能有存储过程或函数等

**CASCADE表示删除没有限制条件。删除基本表时，相关的依赖对象也要被一起删除**

## 3.完成与以下查询等价的SQL表达式

# **HAVING与GROUP BY的详细工作机制**

HAVING 确实是在分组结果上操作，而不是直接在基本表上过滤。这是 HAVING 和 WHERE 的关键区别。

### **执行顺序与数据流**

SQL查询的逻辑执行顺序是：

1. FROM - 确定数据源
2. WHERE - 在原始数据上过滤
3. GROUP BY - 分组
4. 聚合函数计算 (如COUNT, SUM等)
5. HAVING - 在**分组后**的结果上过滤
6. SELECT - 选择最终显示的列
7. ORDER BY - 排序

### **HAVING COUNT(DISTINCT e.course_code)的工作过程**

在我们的例子中：

1. **首先分组**：GROUP BY e.student_id 将数据分为三组
   - S1组：(S1,C1,A), (S1,C2,B), (S1,C3,A)
   - S2组：(S2,C1,B), (S2,C2,C)
   - S3组：(S3,C2,A), (S3,C3,B)
2. **然后在每组内计算**：COUNT(DISTINCT e.course_code)
   - S1组：[C1, C2, C3] → 3门不同课程
   - S2组：[C1, C2] → 2门不同课程
   - S3组：[C2, C3] → 2门不同课程
3. **最后用HAVING筛选**：保留计数等于总课程数的组
   - S1：3 = 3 ✓ 保留
   - S2：2 ≠ 3 ✗ 过滤掉
   - S3：2 ≠ 3 ✗ 过滤掉

### **WHERE vs HAVING**

- **WHERE**：在分组前过滤单个行
- **HAVING**：在分组后过滤整个组

这也是为什么**HAVING子句中可以使用聚合函数(如COUNT, SUM, AVG等)**，而WHERE子句中通常不能使用聚合函数的原因 - 因为WHERE在聚合计算前执行。

**理解了这一点非常好，这是SQL中处理复杂查询的重要基础！**

## 4.设有一个SPJ数据库，包括四个关系模式S,P,J和SPJ

S(SNO,SNAME,STATUS,CITY);

—供应商表S（供应商代码SNO,供应商姓名SNAME,供应商状态STATUS,供应商所在城市CITY）

P(PNO,PNAME,COLOR,WEIGHT);

—零件表P（零件代码PNO,零件名PNAME,颜色COLOR,重量WEIGHT)

J(JNO,JNAME,CITY);

—工程项目表J（工程项目代码JNO,工程项目名JNAME,工程项目所在城市CITY）

SPJ(SNO,PNO,JNO,QTY)

—供应情况表SPJ(供应商代码SNO,零件代码PNO，工程项目代码JNO,供应数量QTY）

—表示某供应商供应某种零件给某工程项目的数量为QTY

查询：

①求供应工程J1零件的供应商代码SNO

```sql
SELECT SNO
FROM SPJ
WHERE JNO = 'J1';
```

②求供应工程J1零件P1的供应商代码SNO

```sql
SELECT SNO
FROM spj
WHERE JNO= 'J1' 
AND PNO = 'P1';
```

③求供应工程J1零件为红色的供应商代码SNO

```sql
SELECT SNO
FROM spj
JOIN P ON SPJ.PNO = P.PNO
WHERE COLOR='红'
AND JNO = 'J1';
```

④求没有使用天津供应商生产的红色零件的工程号JNO

```sql
SELECT DISTINCT JNO
FROM j
WHERE JNO NOT IN
									(SELECT JNO
									FROM spj
									JOIN p ON P.PNO = SPJ.PNO
									JOIN S ON S.SNO = SPJ.SNO
									WHERE COLOR = '红'
									AND CITY = '天津');
```

⑤求至少使用了与供应商S1所供应的全部零件相同零件号的工程号JNO

```sql
-- 先找出供应商是S1的零件号P1,P2
SELECT DIST PNO FROM SPJ WHERE SNO='S1'
-- 再根据结果找出至少使用了P1和P2的工程号
SELECT JNO 
FROM SPJ AS SPJ1
WHERE PNO='P1'
AND SPJ1.JNO IN (
									SELECT JNO 
									FROM SPJ 
									WHERE PNO='P2');
```

## 5.完成SQL操作

```sql
习题三第5题
(1)找出所有供应商的姓名和所在城市。
SELECT SNAME,CITY
FROM s;

(2)找出所有零件的名称、颜色、重量。
SELECT PNAME,COLOR,WEIGHT
FROM p;

(3)找出使用供应商S1所供应零件的工程号码。
SELECT JNO
FROM spj
WHERE SNO = 'S1';

(4)找出工程项目J2使用的各种零件的名称及其数量。
SELECT PNAME,QTY
FROM spj
JOIN p ON p.PNO = spj.PNO
WHERE JNO = 'J2';

(5)找出上海厂商供应的所有零件号码。
SELECT PNO
FROM spj
JOIN s ON s.SNO = spj.SNO
WHERE CITY = '上海';

(6)出使用上海产的零件的工程名称。
SELECT JNAME
FROM j
JOIN spj ON j.JNO = spj.JNO
JOIN s ON S.SNO = spj.SNO
WHERE s.CITY = '上海'

(7)找出没有使用天津产的零件的工程号码。
SELECT DISTINCT j.JNO
FROM j 
WHERE j.JNO NOT IN (
															SELECT spj.JNO
															FROM spj 
															JOIN  j ON j.JNO = spj.JNO
															JOIN s ON s.SNO = spj.SNO
															WHERE s.CITY = '天津'
)
(8)把全部红色零件的颜色改成蓝色。
UPDATE P SET COLOR='蓝' WHERE COLOR='红'

(9)由S5供给J4的零件P6改为由S3供应。
-- 修改表内容用UPDATE,修改表用ALTER
UPDATE SPJ SET SNO='S3' WHERE SNO='S5' AND JNO='J4' AND PNO='P6'

(10)从供应商关系中删除供应商号是S2的记录，并从供应情况关系中删除相应的记录。
-- 删除表用DROP,删除记录用DELETE
DELETE  FROM  S  WHERE  SNO='S2'
DELETE  FROM  SPJ  WHERE  SNO='S2'

(11)请将(S2，J6，P4，200)插入供应情况关系。
INSERT INTO SPJ
VALUES ('S2','J6','P4',200)

```

## 6.什么是基本表？什么是视图？两者的区别与联系？

基本表是本身独立存在的表，在 sQL中一个关系就对应一个表。

视图是从一个或几个基本表导出的表。

视图本身不独立存储在数据库中，是一个虚表。

即数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。

视图在概念上与基本表等同，用户可以如同基本表那样使用视图，可以在视图上再定义视图。

## 基本表

基本表是数据库中**实际存储数据**的表，具有以下特点：
• 物理存在：在数据库中有实际的物理存储空间
• 独立：不依赖于其他表的定义
• 持久性：数据被永久存储，除非显式删除或修改
• 直接：可以直接对其进行增删改查操作

## 视图

视图是**基于**一个或多个**基本表**（或其他视图）的查询结果的**虚拟表**，具有以下特点：
• 虚拟存在：不实际存储数据，只存储视图的定义（SQL查询）
• 依赖性：依赖于基础表的存在
• 动态性：每次访问都会重新执行查询，反映最新数据 `CREATE VIEW只是把视图的定义存入数据字典，并不执行其中的SELECT语句，只有查询时，才执行`
• 简化复杂查询：可以隐藏复杂的SQL操作

## 两者的区别

**存储方式：**
  基本表：实际存储数据
  视图：只存储定义（SQL语句）
**物理存在：**
  基本表：在磁盘上占用实际空间
  视图：仅定义占用少量空间
**操作限制：**
  基本表：可以进行所有DML操作（增删改查）
  视图：有些视图不可更新，特别是包含聚合函数、DISTINCT、GROUP BY等的视图
**依赖关系：**
  基本表：相对独立
  视图：依赖于定义它的基本表，基本表变化会影响视图

## 两者的联系

数据访问：两者都可以通过SQL语句进行查询
用户角度：对于用户来说，访问方式相同
结构相似：视图在逻辑上与基本表结构相似，有列和行
相互转化：视图的查询结果可以创建为新的基本表
功能互补：视图可以基于多个基本表，而基本表提供了视图的数据基础

视图可以看作是基本表数据的一个**"窗口"或"接口"**，提供了数据的不同展现方式，而不需要复制或改变基础数据。

组成视图的属性列要么全部省略，要么全写。当以下情况要全写：

1. 某个列不是单纯的属性名，是聚集函数或列表达式
2. 多表连接时出现同名列
3. 需要在视图中起一个更合适的名字

## 7.视图的优点

1. **视图能够对机密数据提供安全保护**
   对不同的用户定义不同的视图
2. **视图对重构数据库提供了一定程度的逻辑独立性**
   数据库重构造时，如增加新的关系或对原有关系增加新的字段等，用户的应用程序不会受影响

   ```sql
   学生关系Student(Sno,Sname,Ssex,Sbirthdate,Smajor) 
   	   “垂直”地分成两个基本表：
         SX(Sno,Sname,Sbirthdate)      
   	    SY(Sno,Ssex,Smajor)
   通过建立一个视图Student：
   CREATE VIEW  Student(Sno,Sname,Ssex,Sbirthdate,Smajor)
   AS  
   SELECT  SX.Sno,SX.Sname,SY.Ssex,SX.Sbirthdate,SY.Smajor
   FROM  SX,SY
   WHERE  SX.Sno=SY.Sno;
   使**用户的外模式**保持不变，用户的**应用程序通过视图仍然能够查找数据**
   ```
3. **视图能够简化用户的操作**基于多张表连接形成的视图，避免每次查询都要连接。
4. **视图使用户能以多种角度看待同一数据**
   便于共享同一个数据库， 如：有的教师喜欢看平均成绩，有的喜欢最高成绩，有的喜欢最低成绩。

## 8.哪些视图是可以更新的？哪些不可以？

WITH CHECK OPTION表示对视图进行UPDATE,INSERT,DELETE时，保证影响的行满足视图定义中的条件

如：

```sql
CREATE VIEW IS_Student
AS
SELECT Sno,Ssex,Sbirthdate,Smajor
FROM student
WHERE Smajor='软件工程'
WITH CHECK OPTION;

**以后对该视图进行变动，会自动检查Smajor='软件工程'**
```

## 可以更新的视图

1. 简单视图：只从单个基本表导出的视图
2. 列直接映射：视图的列直接对应于基本表的列，不是计算结果或表达式
3. 包含唯一标识：视图包含基本表的主键或唯一标识列
4. 基本操作：视图定义中只使用了基本的 SELECT 操作
5. 无派生列：不包含通过计算或函数生成的列

```sql
CREATE VIEW 员工视图 AS
SELECT 员工ID, 姓名, 部门, 薪资
FROM 员工表
WHERE 部门 = '技术部';
```

## 不可更新的视图

1. 包含聚合函数：使用了 SUM, COUNT, AVG, MAX, MIN 等
2. 使用 DISTINCT：去除了重复行
3. 包含 GROUP BY 子句：对数据进行了分组
4. 包含 HAVING 子句：对分组结果进行了筛选
5. 多表连接视图：基于多个表的连接操作
6. 包含集合操作：使用了 UNION, INTERSECT, MINUS 等
7. 包含子查询：特别是在 SELECT 列表中的子查询
8. 不包含所有必需列：缺少基本表中的非空且没有默认值的列

```sql
CREATE VIEW 部门统计 AS
SELECT 部门, COUNT(*) AS 员工数, AVG(薪资) AS 平均薪资
FROM 员工表
GROUP BY 部门;
```

## 9.创建视图，完成题目

```sql
请为三建工程项目建立一个供应情况的视图，包括供应商代码(SNO)、零件代码(PNO)、供应数量(QTY)。
CREATE VIEW 三建工程视图
AS
SELECT SNO,PNO,QTY
FROM spj
JOIN j ON j.JNO = spj.JNO
WHERE JNAME = '三建';

针对该视图VSP完成下列查询：
(1)找出三建工程项目使用的各种零件代码及其数量。
SELECT DISTINCT PNO,QTY
FROM 三建工程视图;

(2)找出供应商S1的供应情况。
SELECT DISTINCT SNO,PNO,QTY
FROM 三建工程视图
WHERE SNO='S1';
```

## 10.什么是空值？举例说明。SQL中如何表示空值？空值该如何参与运算？

空值就是“不知道”，“不存在”，“无意义”的值。

### **取空值的情况：**

1. 该属性应该有一个值，但是目前不知道具体值。如学生填写学生登记表时漏了出生日期，不知道该学生此信息，暂时空值。
2. 该属性不应该有值。如缺考学生的成绩为空。
3. 不便于填写。如 注册时，非必要项可以不填写，提交后该字段为空值。

**空值是一个很特殊的值，含有不确定性。对关系运算带来特殊的问题，需要做特殊的处理。**

### **空值的产生**

**`INSERT INTO SC(Sno,Cno,Grade,Semester,Teachingclass)`**

**`VALUES('20180006', '81004',NULL, '20211',NULL);` 显式给出**

**或**

**`INSERT INTO SC(Sno,Cno,Semester)`**

**`VALUES('20180006', '81004','20211');`自动置空值**

1. 外连接也会产生空值，悬浮元组
2. 空值的关系运算也会产生空值

### **空值的判断**

用IS NULL 或IS NOT NULL

```sql
SELECT *
	FROM Student
	WHERE Sname IS NULL OR Ssex IS NULL OR Sbirthdate IS NULL OR Smajor IS NULL;
           -- Sno是主码，不允许取空值，不许漏填。

```

### **空值的约束**

    属性定义为NOT NULL，主码的属性不能取空值。

### **空值的算术运算、比较运算和逻辑运算**

1. 空值与另一个值（包括另一个空值）的**算术运算**的结果为**空值**
2. 空值与另一个值（包括另一个空值）的**比较运算**的结果为**UNKNOWN**。
3. 逻辑运算AND,OR,NOT真值表

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2026.png)

1. 例子

```sql
选出选修81001号课程且成绩不及格的学生以及缺考的学生。

	SELECT Sno
	FROM SC
	WHERE Grade < 60 AND Cno='81001'
	UNION
	SELECT Sno
	FROM SC
	WHERE Grade IS NULL AND Cno='81001';
或
	SELECT Sno
	FROM SC
	WHERE Cno='81001' AND (Grade < 60 OR Grade IS NULL);

```

```sql
找出选修81001号课程且成绩不及格的学生。

	SELECT Sno
	FROM SC
	WHERE Grade < 60 AND Cno='81001’;

 选出的学生是那些参加了考试而成绩不及格（Grade属性为非空值）的学生，
   **不包括缺考**（Grade属性为空值）的学生
 **因为前者使条件Grade<60的值为TRUE，**

```

# 第四章 数据库安全性

## 1.什么是数据库的安全性？

数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏。

## 2.数据库安全性和计算机系统的安全性有什么关系？

安全性问题不是数据库系统所独有的，所有计算机系统都有这个问题。只是在数据库系统中大量数据集中存放，而且为许多最终用户直接共享，从而使安全性问题更为突出。系统安全保护措施是否有效是数据库系统的主要指标之一。

数据库的安全性和计算机系统的安全性，包括操作系统、网络系统的安全性是紧密联系、相互支持的。

## 3.实现数据库安全性控制的常用方法和技术

( l）**用户标识和鉴别**：该方法由系统提供一定的方式让用户标识自己的名字或身份。**每次用户要求进入系统时**，由系统进行核对，通过鉴定后才提供系统的使用权。

( 2）**存取控制**：通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未被授权的人员无法存取数据。

( 3）**视图机制**：**为不同的用户定义视图**，通过视图机制把要**保密的数据对无权存取的用户隐藏起来**，从而自动地对数据提供一定程度的安全保护。

( 4）**审计**：建立审计日志，把用户对数据库的所有操作**自动记录下**来放入**审计日志**中，DBA可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。

( 5）**数据加密**：对存储和传输的数据进行**加密处理**，从而使得不知道解密算法的人无法获知数据的内容。

## 4.什么是数据库中的自主存取控制方法和强制存取控制方法？

C2级中的自主存取控制( DAC ) , B1级中的强制存取控制（MAC）。

自主存取控制方法：定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。

强制存取控制方法：每一个数据对象被（强制地）标以**一定的密级**，每一个**用户**也被（强制地）**授予某**一个**级别**的**许可证**。
`绝密级（top secret,TS) ≥ 机密级（secert，S）≥ 秘密级（confidential，C）≥公开（public，P）`

主体 `（用户）`的敏感性标记称为许可证级别，客体 `（文件，基本表，索引，视图）`的敏感度标记称为密级

规则：

①主体的许可证级别**≥**客体的密级，才能读取相应的客体   （权限高的用户可以读低级的数据对象）

②主体的许可证级别≤客体的密级，才能写相应的客体        （只能向上级的写，若向下写，则上层绝密数据可以被写到公开级，导致泄露）

## 5.对以下两个关系模式

学生（学号，姓名，年龄，性别，家庭住址，班级号）

班级（班级号，班级名，班主任，班长）

用SQL的GRANT语句完成授权

① 授予用户U1对两个表的所有权限，并可给其他用户授权

```sql
GRANT ALL PRIVILEGES 
ON TABLE 学生，班级
TO U1
WITH GRANT OPTION
```

②授予用户U2对 学生 表具有查看权限，对 家庭住址 具有更新权限

```sql
GRANT SELECT, UPDATE(家庭住址)
ON TABLE 学生
TO U2
```

③将对 班级 表查看权限授予所有用户

```sql
GRANT SELECT
ON TABLE 班级
TO PUBLIC
```

④将对 学生 表的查询，更新权限授予角色R1

```sql
CREATE ROLE R1;
GRANT SELECT,UPDATE
ON TABLE 学生
TO R1
```

⑤将角色R1授予用户U1,并且U1可继续授权给其他角色

```sql
GRANT R1
TO U1
WITH ADMIN OPTION

注意角色是WITH ADMIN OPTION
用户是WITH GRANT OPTION
```

## 6.对以下两个关系模式

职工（职工号，姓名，年龄，职务，工资，部门号）

部门（部门号，名称，经理名，地址，电话号）

请用SQL的GRANT和REVOKE语句(加上视图机制)完成以下授权定义或存取控制功能:

( a）用户王明对两个表有SELECT权

```sql
GRANT SELECT
ON TABLE 职工，部门
TO 王明
```

( b）用户李勇对两个表有INSERT和DELETE权

```sql
GRANT INSERT,DELETE
ON TABLE 职工，部门
TO 李勇
```

( c )每个职工只对自己的记录有SELECT权

```sql
-- 为每个职工创建个人视图
CREATE VIEW 个人信息_职工号 
AS
SELECT * 
FROM 职工
WHERE 职工号 = USER();  -- 假设职工号与数据库用户名相同

-- 为每个职工授予对应视图的查询权限
GRANT SELECT 
ON 个人信息_职工号 
TO 职工号;
```

( d）用户刘星对职工表有SELECT权力，对工资字段具有更新权

```sql
GRANT SELECT,UPDATE(工资)
ON TABLE 职工
TO 刘星
```

 ( e）用户张新具有修改这两个表的结构的权

```sql
GRANT ALTER TABLE
ON TABLE 职工，部门
TO 张新
```

( f）用户周平具有对两个表所有权限（读，插，改，删数据），并具有给其他用户授权的权

```sql
GRANT ALL PRIVILEGES
ON TABLE 职工，部门
TO 周平
WITH GRANT OPTION
```

( g）用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权力，他不能查看每个人的工资

```sql
CREATE VIEW 部门工资统计
AS
SELECT 部门号，
				MAX(工资) AS 最高工资,
				MIN(工资) AS 最低工资,
				AVG(工资) AS 平均工资
FROM 职工
GROUP BY 部门号;  每个部门职工中

GRANT SELECT
ON 部门工资统计
TO 杨兰;
```

## 7.把习题6中（1）---（7）的每一种情况，撤销各用户所授予的权力

## (a) 撤销用户王明对两个表的SELECT权

```sql
REVOKE SELECT 
ON 职工,部门 
FROM 王明;
```

## (b) 撤销用户李勇对两个表的INSERT和DELETE权

```sql
REVOKE INSERT, DELETE 
ON 职工,部门 
FROM 李勇;
```

## (c) 撤销每个职工对自己记录的SELECT权

```sql
-- 撤销每个职工对个人视图的查询权限
REVOKE SELECT ON 个人信息_职工号 FROM 职工号;

-- 删除为职工创建的个人视图
DROP VIEW 个人信息_职工号;
```

## (d) 撤销用户刘星对职工表的SELECT权力和工资字段的更新权

```sql
REVOKE SELECT,UPDATE (工资)
 ON 职工 
 FROM 刘星;
```

## (e) 撤销用户张新修改两个表结构的权

```sql
REVOKE ALTER 
ON 职工,部门 
FROM 张新;
```

## (f) 撤销用户周平对两个表的所有权限及授权权

```sql
REVOKE ALL PRIVILEGES 
ON 职工,部门 
FROM 周平 CASCADE;
```

## (g) 撤销用户杨兰查看部门工资统计的权力

```sql
-- 撤销杨兰对部门工资统计视图的查询权限
REVOKE SELECT ON 部门工资统计 FROM 杨兰;

-- 删除部门工资统计视图
DROP VIEW 部门工资统计;
```

## 8.理解并解释MAC机制中主体、客体、敏感度标记的含义。

自主存取空值授予用户权限之后，用户可以在权限范围内随意使用数据，可以备份及传播副本，导致泄露，**数据本身并无安全性标记**

主体 `（实际用户）`的敏感性标记称为**许可证级别**，客体 `（受主体操纵的，包括文件，基本表，索引，视图）`的敏感度标记称为**密级**

`绝密级（top secret,TS) ≥ 机密级（secert，S）≥ 秘密级（confidential，C）≥公开（public，P）`

规则：

①主体的许可证级别**≥**客体的密级，才能读取相应的客体   （权限高的用户可以读低级的数据对象）

②主体的许可证级别≤客体的密级，才能写相应的客体        （只能向上级的写，若向下写，则上层绝密数据可以被写到公开级，导致泄露）

## 9.举例说明强制存取控制机制是如何确定主体能否存取客体的

强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据是不可分割的整体。只有符合密级标记要求的用户才可以操纵数据。

自主存取控制与强制存取控制共同构成数据库管理系统的安全机制。    MAC安全级别较高，包含DAC。

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2027.png)

**只有通过最终MAC检查才可存取。**

## 10.什么是数据库的审计功能，为什么要提供审计功能？

审计功能：把用户对数据库的所有操作自动记录下来放入审计日志。

`因为任何系统的安全保护措施都不是完美无缺的，蓄意盗窃破坏数据的人总可能存在。`

`利用数据库的审计功能，DBA可以根据审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的用户 、时间和内容等。`

```sql
SHOW AUDIT_TRAIL;显示审计开关状态
```

```sql
SET AUDIT_TRAIL TO ON; 打开审计
```

```sql
AUDITT ALTER,UPDATE
ON SC
BY ACCESS  对SC表设置审计
```

BY ACCESS 对每个设置的审计操作都要记录

BY SESSION 表示对每次会话中涉及的同类审计操作，只记录最早的一次。

## 11.SQL语言中提供了哪些数据控制（自主存取控制）的语句？请试举几例说明它们的使用方法。

SQL中的自主存取控制是通过GRANT语句和REVOKE语句来实现的。

如：

`GRANT SELECT , INSERT ON Student  TO王平 WITH GRANT  OPTION ;`就将Student表的SELECT和INSERT权限授予了用户王平，后面的“WITH GRANT OPTION”子句表示用户王平同时也获得了“授权”的权限，即可以把得到的权限继续授予其他用户

---

---

---

`REVOKE INSERT ON Student FROM 王平 CASCADE ;`

就将Student表的INSERT权限从用户王平处收回，选项CASCADE表示，如果用户王平将Student的INSERT权限又转授给了其他用户，那么这些权限也将从其他用户处收回。

# 第五章 数据库完整性

## 1.什么是数据库的完整性？

数据库的完整性是指数据的**正确性**和**相容性**。防止数据库中存在不符合语义和不正确的数据。

**数据的正确性**

数据是符合现实世界语义，反映了当前的实际状况

**数据的相容性**

数据库同一对象在不同关系表中的数据是相同的

```sql
例如：
学生的学号必须唯一
百分制的课程成绩取值范围为0-100
学生所选的课程必须是学校开设的课程
学生所在的院系必须是学校已成立的院系等
```

## 2.数据库的完整性概念与数据库的安全性概念有什么区别和联系？

**数据的完整性**
          防止数据库中存在不符合语义的数据，防止数据库中存在不正确的数据
          防范对象：不合语义的、不正确的数据
**数据的安全性**
          保护数据库防止恶意的破坏和非法的存取
          防范对象：非法用户和非法操作

## 3.什么是数据库的完整性约束条件？可分为哪几类？

完整性约束条件是指数据库中的数据应该满足的语义约束条件。

常见的静态关系约束有： ( l）实体完整性约束；( 2）参照完整性约束；( 3）用户定义完整性约束。

## 4.DBMS的完整性控制机制应具有哪些功能？

1. **提供定义完整性约束的机制**
   由SQL的数据定义语言语句来实现，包括关系模型的实体完整性、参照完整性和用户定义完整性，数据库中的数据必须满足的语义约束。
2. **提供检查完整性约束的方法**
   检查数据是否满足完整性约束的机制
   *一般在INSERT、UPDATE、DELETE语句执行后开始检查，也可以在事务提交时检查*
3. **提供完整性的违约处理方法**
   用户的操作违背了完整性约束，就采取一定的动作
   **拒绝（NO ACTION）执行该操作，级连（CASCADE）执行其他操作**

## 5.DBMS在实现参照完整性时需要考虑哪些方面？

当违反了参照完整性时，系统选用默认策略**拒绝执行(NO ACTION)，**若想让系统采用其他策略，需要创建参照时显式的给出。

级联操作 CASCADE      不一致，则删除或修改参照表中的所有导致不一致的元组

设置为空值SET NULL        不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。

![参照完整性情况及违约处理](image%2028.png)

参照完整性情况及违约处理

## 1. 拒绝执行(NO ACTION)

示例场景：部门表(Department)和员工表(Employee)的关系，员工表的dept_id是外键，引用部门表的id。

```sql
CREATE TABLE Department (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE Employee (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES Department(id)
    -- 默认为NO ACTION
);

-- 插入数据
INSERT INTO Department VALUES (1, '研发部');
INSERT INTO Department VALUES (2, '市场部');
INSERT INTO Employee VALUES (101, '张三', 1);
INSERT INTO Employee VALUES (102, '李四', 2);

-- 尝试删除仍有员工的部门
DELETE FROM Department WHERE id = 1;  -- 操作被拒绝

```

结果：系统拒绝删除操作并返回错误，因为部门1中还有员工，违反了参照完整性。

## 2. 级联操作(CASCADE)

```sql
CREATE TABLE Department (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE Employee (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES Department(id)
    ON DELETE CASCADE ON UPDATE CASCADE
);

-- 插入数据
INSERT INTO Department VALUES (1, '研发部');
INSERT INTO Department VALUES (2, '市场部');
INSERT INTO Employee VALUES (101, '张三', 1);
INSERT INTO Employee VALUES (102, '李四', 2);

-- 删除研发部
DELETE FROM Department WHERE id = 1;

```

结果：研发部被删除，同时张三的记录也被自动删除，因为CASCADE策略导致删除操作级联到了引用表。

## 3. 设置为空值(SET NULL)

```sql
CREATE TABLE Department (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE Employee (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES Department(id)
    ON DELETE SET NULL
);

-- 插入数据
INSERT INTO Department VALUES (1, '研发部');
INSERT INTO Department VALUES (2, '市场部');
INSERT INTO Employee VALUES (101, '张三', 1);
INSERT INTO Employee VALUES (102, '李四', 2);

-- 删除研发部
DELETE FROM Department WHERE id = 1;

```

结果：研发部被删除，张三的部门ID字段被自动设置为NULL，表示该员工目前不属于任何部门，但员工记录本身被保留。

## 6.假设有下面两个关系模式：

职工（职工号，姓名，年龄，职务，工资，部门号）

部门（部门号，名称，经理名，电话）

①定义每个模式的主码；

②定义参照完整性；

③定义职工年龄不得超过65岁。

```sql
CREATE TABLE Department(
																					Department_no CHAR(5) PRIMARY KEY,
																					Dep_name VARCHAR(10),
																					Dep_Manager_Name VARCHAR(10),
																					Dep_Tel CHAR(20)
																					);

CREATE TABLE Employees(
																				Emp_no char(10) PRIMARY KEY,
																				Emp_name varchar(10),
																				Emp_age SMALLINT(3) CHECK (Emp_age <= 65),
																				Emp_job VARCHAR(10),
																				Emp_salary SMALLINT(10),
																				Department_no CHAR(5),
																				CONSTRAINT Emp_foreignKey
																							FOREIGN KEY(Department_no) 
																							REFERENCES Department(Department_no)
																				);
```

## 7.关系系统中，当操作违反实体完整性、参照完整性和用户定义的完整性约束条件时，一般是如何分别进行处理的？

### 实体完整性：

如设置PRIMARY KEY之后，每次插入记录都要检查：  否则拒绝
      ①主码值是否唯一。
      ②主码是否为空。

检查主码值是否唯一有两种方法：①全表扫描，依次判断，十分耗时。②建立索引，数据库一般在主码上自动建立一个索引，大大提高效率。

### 参照完整性：

见第5题。

### 用户自定义完整性

当向表中插入元组或修改属性的值时，不满足则拒绝执行

# 第六章 关系数据理论

## 范式

```jsx
我需要对每种范式提供:
1. 简明的定义
2. 详细的例子
3. 范式之间的转化过程
让我组织一下回答:
**1NF (第一范式)**
• 定义：每个属性都是原子的，不可再分
• 例子：学生表中的"地址"拆分为"省份"、"城市"、"街道"等
**2NF (第二范式)**
• 定义：满足1NF，且所有非主属性完全依赖于主键
• 例子：订单明细表分离为订单表和订单明细表
**3NF (第三范式)**
• 定义：满足2NF，且所有非主属性都不传递依赖于主键
• 例子：学生表中分离出学院信息
**BCNF (BC范式)**
• 定义：满足3NF，且所有决定因素都是候选键
• 例子：课程与教师的关系
对于每个例子，我会展示：
1. 原始表结构及其问题
2. 如何判断它属于哪个范式
3. 如何转化为更高范式的具体步骤
4. 转化后的表结构及优势
我会加粗重点内容，使用实际的表格示例，并保持解释简明易懂。

1. 简明的定义
2. 详细的例子
3. 范式之间的转化过程
- 定义：每个属性都是原子的，不可再分
- 例子：学生表中的"地址"拆分为"省份"、"城市"、"街道"等
- 定义：满足1NF，且所有非主属性完全依赖于主键
- 例子：订单明细表分离为订单表和订单明细表
- 定义：满足2NF，且所有非主属性都不传递依赖于主键
- 例子：学生表中分离出学院信息
- 定义：满足3NF，且所有决定因素都是候选键
- 例子：课程与教师的关系
1. 原始表结构及其问题
2.  如何判断它属于哪个范式
3. 如何转化为更高范式的具体步骤
4. 转化后的表结构及优势
```

## **关系数据库范式详解与转化示例**

## **第一范式 (1NF)**

**第一范式要求表中的每个属性都是原子的，不可再分**。

### **例子：学生信息表（不满足1NF）**

| **学号** | **姓名** | **联系方式**                                                               |
| -------------- | -------------- | -------------------------------------------------------------------------------- |
| 001            | 张三           | 电话:13812345678,邮箱:[**zhangsan@example.com**](mailto:zhangsan@example.com) |
| 002            | 李四           | 电话:13987654321,邮箱:[**lisi@example.com**](mailto:lisi@example.com)         |

**问题**：联系方式列包含多个值，不是原子的。

### **转化为1NF**

| **学号** | **姓名** | **电话** | **邮箱**                                             |
| -------------- | -------------- | -------------- | ---------------------------------------------------------- |
| 001            | 张三           | 13812345678    | [**zhangsan@example.com**](mailto:zhangsan@example.com) |
| 002            | 李四           | 13987654321    | [**lisi@example.com**](mailto:lisi@example.com)         |

## **第二范式 (2NF)**

**第二范式在满足1NF的基础上，要求所有非主键属性完全依赖于主键**，而不是依赖于主键的一部分。

### **例子：选课记录表（满足1NF但不满足2NF）**

| **学号** | **课程编号** | **学生姓名** | **课程名称** | **成绩** |
| -------------- | ------------------ | ------------------ | ------------------ | -------------- |
| 001            | C001               | 张三               | 数据库             | 85             |
| 001            | C002               | 张三               | 算法               | 90             |
| 002            | C001               | 李四               | 数据库             | 78             |

**问题**：主键是(学号,课程编号)的组合，但学生姓名只依赖于学号，课程名称只依赖于课程编号，这是**部分依赖**。

### **转化为2NF (拆分为三个表)**

**学生表**:

| **学号** | **学生姓名** |
| -------------- | ------------------ |
| 001            | 张三               |
| 002            | 李四               |

**课程表**:

| **课程编号** | **课程名称** |
| ------------------ | ------------------ |
| C001               | 数据库             |
| C002               | 算法               |

**选课成绩表**:

| **学号** | **课程编号** | **成绩** |
| -------------- | ------------------ | -------------- |
| 001            | C001               | 85             |
| 001            | C002               | 90             |
| 002            | C001               | 78             |

## **第三范式 (3NF)**

**第三范式在满足2NF的基础上，要求非主键属性不传递依赖于主键**。

### **例子：学生信息表（满足2NF但不满足3NF）**

| **学号** | **姓名** | **系部编号** | **系部名称** | **系部主任** |
| -------------- | -------------- | ------------------ | ------------------ | ------------------ |
| 001            | 张三           | D01                | 计算机系           | 王教授             |
| 002            | 李四           | D01                | 计算机系           | 王教授             |
| 003            | 王五           | D02                | 数学系             | 刘教授             |

**问题**：系部名称和系部主任依赖于系部编号，而系部编号依赖于学号，这是**传递依赖**。

### **转化为3NF**

**学生表**:

| **学号** | **姓名** | **系部编号** |
| -------------- | -------------- | ------------------ |
| 001            | 张三           | D01                |
| 002            | 李四           | D01                |
| 003            | 王五           | D02                |

**系部表**:

| **系部编号** | **系部名称** | **系部主任** |
| ------------------ | ------------------ | ------------------ |
| D01                | 计算机系           | 王教授             |
| D02                | 数学系             | 刘教授             |

## **BCNF (Boyce-Codd范式)**

**BCNF在满足3NF的基础上，要求所有决定因素必须是候选键**。

### **例子：教师课程表（满足3NF但不满足BCNF）**

假设有以下约束条件：

- 一个教师只教一门课程
- 一门课程可以由多个教师教授
- 每个教室在特定时间只能安排一门课程

| **教师编号** | **课程编号** | **教室** | **时间** |
| ------------------ | ------------------ | -------------- | -------------- |
| T01                | C01                | R101           | 周一上午       |
| T02                | C01                | R102           | 周二下午       |
| T03                | C02                | R103           | 周三上午       |

**问题**：教师编号决定课程编号（一个教师只教一门课），但教师编号不是候选键。

### **转化为BCNF**

**教师课程表**:

| **教师编号** | **课程编号** |
| ------------------ | ------------------ |
| T01                | C01                |
| T02                | C01                |
| T03                | C02                |

**课程安排表**:

| **课程编号** | **教室** | **时间** |
| ------------------ | -------------- | -------------- |
| C01                | R101           | 周一上午       |
| C01                | R102           | 周二下午       |
| C02                | R103           | 周三上午       |

## **范式转化的实际意义**

**范式的提高带来的好处**:

- **减少数据冗余**
- **避免更新异常**
- **提高数据一致性**

但在实际应用中，有时会为了**查询性能**而适当降低范式标准，这称为"**反规范化**"。

每个项目需要根据具体业务需求，在**数据完整性**和**系统性能**之间找到平衡点。

## 1.理解并给出下列术语的定义：

函数依赖、部分函数依赖、完全函数依赖、传递依赖、候选码、主码、外码、全码（All一key）、1 NF、ZNF、3NF、BcNF、多值依赖、4NF。

1. 函数依赖：关系模式R(U,F)，X和Y是U的子集，对于R上任意一个关系，只要X上属性的值相等，则Y的值也相等。即X唯一确定Y。X是决定因素
   `注意：函数依赖在该关系模式中永远需要被满足。`
2. 部分函数依赖：X中的一部分就可以唯一确定Y,叫Y对X部分函数依赖。
3. 完全函数依赖：X的任何真子集都不能决定Y，是完全函数依赖。
4. 传递依赖：X→Y,Y→Z,且Y—\→X,且都是非平凡依赖，则Z对X传递函数依赖
5. 候选码：K为R(U,F)中的一个属性或一**组**属性**，唯一确定元组的最小属性集合，**若U**完全**函数依赖于K,则K为R的候选码。
6. 超码：U部份依赖于K，则K为超码。 也就是在候选码基础上可以再多几个属性，不要求最小性
7. 主码:若关系模式R有多个候选码，则选定其中的一个做为主码
8. **全码:**整个属性组是码
9. **外码:**   X非R的码，却是另一个关系的码
10. 1NF：关系模式R的每一个分量是不可再分的数据项
11. 2NF：若关系模式R∈1NF，且每一个**非主属性**完全函数依赖于**码**，则关系模式R∈2NF。`消除了非主属性对码的部分函数依赖`
12. 3NF：若关系模式R∈1NF，消除了非主属性对码的传递依赖，也无非主属性对码的部分依赖
13. BCNF：修正的第三范式。决定因素必须≥候选码（超键） **，**且**主属性，非主属性都没有对候选码的非完全和传递依赖。**
14. 多值依赖：R(U,F)，有X,Y,Z三个子集，Z=U-X-Y   给定**一对(x,z)值**，可以确定**一组**Y值，且仅仅取决于x,**与z无关**。则X→→Y成立
    表示对于给定的 X 值，Y 的**值集合**与其他属性的值没有联系。
    注：它的平凡依赖是指Z为空集，X和Y的并集构成了整个U。或  Y为X子集
15. 4NF：    4NF就是限制关系模式的属性之间**只允许**有**平凡且函数依赖**的多值依赖。
16. 主属性：候选码中的属性是主属性

## 2.建立一个包含 系，学生，班级，学会等信息的关系数据库

学生：学号、姓名、出生年月、系名、班号、宿舍区。
班级：班号、专业名、系名、人数、入校年份。
系：系名、系号、系办公地点、人数。
学会：学会名、成立年份、办公地点、人数。

语义如下：一个系有若干专业，每个专业每年只招一个班，每个班有若干学生。一个系的学生住在同一宿舍区。每个学生可参加若干学会，每个学会有若干学生。学生参加某学会有一个入会年份。
1.请给出关系模式，写出每个关系模式的极小函数依赖集，指出是否存在传递函数依赖，对于函数依赖左部是多属性的情况讨论函数依赖是完全函数依赖，还是部分函数依赖。
2.指出各关系模式的候选码、外部码，有没有全码存在?

![数据库_20250304_165956.jpg](%E6%95%B0%E6%8D%AE%E5%BA%93_20250304_165956.jpg)

## 3.试由Armstrong公理系统推导下面三条推理规则

①合并规则：若X→Z,X→Y,则X→YZ

②伪传递规则：由X→Y,WY→Z,有XW→Z

③分解规则：X→Y,Z∈Y,有X→Z

## 4.给定关系模式R(U,F) 其中U=

若存在函数依赖B→D,DE→C,EC→B,列出R中所有的码，并给出主属性，非主属性

## 5.试举出三个多值依赖的例子

多值依赖是关系型数据库中的一个概念，通常表示为 X →→ Y，表示对于给定的 X 值，Y 的值集合与其他属性的值没有联系。

## **例子1：学生选课系统**

考虑一个关系 R(学号, 课程, 教材)，其中：

- **学号** 是学生的唯一标识
- **课程** 是学生选择的课程
- **教材** 是对应课程使用的教材

这里存在多值依赖: **学号 →→ 课程**，因为一个学生可以选择多门课程，且学生选什么课程与使用什么教材无关。

同样，**课程 →→ 教材**，因为一门课程可能有多本推荐教材，且这与哪些学生选课无关。

## **例子2：员工项目分配**

考虑关系 R(员工ID, 项目, 技能)，其中：

- **员工ID** 标识特定员工
- **项目** 表示员工参与的项目
- **技能** 表示员工掌握的技能

存在多值依赖: **员工ID →→ 项目**，因为一个员工可以同时参与多个项目，且员工参与什么项目与拥有什么技能无关。

同样，**员工ID →→ 技能**，因为员工可以掌握多种技能，这与参与什么项目无关。

## **例子3：出版物分类系统**

考虑关系 R(书籍ID, 作者, 类别)，其中：

- **书籍ID** 唯一标识一本书
- **作者** 表示参与编写该书的作者
- **类别** 表示该书籍所属的分类

存在多值依赖: **书籍ID →→ 作者**，因为一本书可以有多个作者，且书籍由哪些作者编写与属于什么类别无关。

同样，**书籍ID →→ 类别**，因为一本书可以属于多个类别，这与作者是谁无关。

## 6.考虑关系模式R(U,F)，U=、

①若A是R 的候选码，R具有函数依赖BC→DE,那么在什么条件下R属于BCNF?

②如果存在函数依赖F={A→B,BC→D,DE→A}列出R所有的码

③如果存在函数依赖F={A→B,BC→D,DE→A}，R属于3NF还是BCNF?

## 7.下面的结论哪些正确？哪些错误？错误的请给出理由或反例

二目关系是指只有两个属性的关系。

1. 任何一个二目关系都属于3NF
   ✅
   `在任何情况下，二目关系中不可能有非键属性依赖于另一个非键属性（因为最多只有两个属性），所以不会有传递依赖。因此，任何二目关系都满足3NF的定义。`
2. 任何一个二目关系都属于BCNF
   ✅
   `在二目关系中，如果存在函数依赖，依赖的决定项一定是单一属性，而被决定的属性也只能是另一个属性。如果这个决定项不是码，那么它就不能唯一确定元组，它们之间就不存在函数依赖。因此，在二目关系中，如果存在函数依赖，决定项必然是码。`
3. 任何一个二目关系都属于4NF
   ✅
   `X,Y,Z三个元素，二目关系中，XYZ其中一个必是空集，是平凡函数依赖的多值依赖`
4. 若R.A→R.B,R.B→R.C,则R.A→R.C
   根据Armstrong的传递率 ✅
5. 若R.A→R.B,R.A→R.C,则R.A→R.(B,C)
   ✅根据合并规则
6. 若R.B→R.A,R.C→R.A,则R.(B,C)→R.A
   `如果B→A且C→A都成立，那么对于任何给定的B值，A都是唯一的；对于任何给定的C值，A也都是唯一的。`但是B∪C之后，确定的A不一定唯一。❌
7. 若R.(B,C)→R.A,则R.B→R.A,R.C→R.A
   ❌
   由两个属性B,C才可唯一决定A，但其中一个不一定能唯一确定A。
   如 专业名+课程→ 教师，其中一个并不能唯一确定教师

# 第七章 数据库设计

## 1.试描述数据库设计过程

( l）需求分析：准确了解与分析用户需求（包括数据与处理）。

( 2）概念结构设计：通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型。E-R图

( 3）逻辑结构设计：将概念结构转换为关系模式，并对其进行优化。

( 4）数据库物理设计：为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。

( 5）数据库实施：设计人员运用DBMS提供的数据语言、工具及宿主语言，根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。

( 6）数据库运行和维护：在数据库系统运行过程中对其进行评价、调整与修改。

## 2.数据库设计过程中形成的数据库模式

( l）在概念设计阶段形成独立于机器特点，独立于各个DBMS产品的概念模式，在本篇中就是E一R图；

( 2）在逻辑设计阶段将E一R图转换成具体的数据库产品支持的数据模型，如关系模型，形成数据库逻辑模式，然后在基本表的基础上再建立必要的视图，形成数据的外模式；

( 3）在物理设计阶段，根据DBMS特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式。

## 3.需求分析阶段的设计目标是什么？调查内容是什么？

目标：详细调查现实世界要处理的对象，充分了解用户的各种需求，在其基础上确定新系统的功能。

调查内容：调查的重点是“数据”和“处理”

1️⃣信息要求。根据用户需要得出在数据库中需要存储哪些数据

2️⃣处理要求。用户要完成的数据处理功能，以及对处理性能的要求

3️⃣安全性与完整性要求。

## 4.需求分析阶段得到的数据字典的内容和作用？

数据字典是数据的描述，在需求分析阶段建立，在设计过程中不断充实完善的。

内容：

1. 数据项：  不可再分的数据单位。
2. 数据结构：反映数据项之间的组合关系。可由若干数据项或若干数据结构或混合而成
3. 数据流：数据结构在系统内传输的路径。
4. 数据存储：数据结构停留或保存的地方
5. 处理过程：包含数据的输入输出数据流以及处理方法

作用：

1. **元数据管理**：数据字典存储和管理关于数据库中数据的数据(元数据)，包括表、字段、关系、约束等信息。
2. **数据标准化**：帮助建立和维护组织内部的数据标准，确保数据的一致性和规范性。
3. **文档化工具**：提供完整的数据库结构文档，记录每个数据元素的详细信息
4. 是概念设计的基础

## 5.什么是数据库的概念结构？

概念结构是信息世界的结构，即概念模型。

### 主要特点

 ( l）**能真实、充分地反映现实世界**，包括事物和事物之间的联系，能满足用户对数据的处理要求，是对现实世界的一个真实模型；

( 2）**易于理解**，从而可以用它和不熟悉计算机的用户交换意见，用户的积极参与是数据库设计成功的关键；

( 3）**易于更改**，当应用环境和应用要求改变时，容易对概念模型修改和扩充；

( 4）**易于向**关系、网状、层次等各种**关系模型转换**。

## 6.定义并解释概念模型中的以下术语

实体：是指现实世界中可区分的事物，具有独立存在的意义。`是物理上存在的对象(如学生、教师、设备)，`

实体型：**实体型**是具有相同属性的一类实体的**抽象**，例如"学生"、"教师"、"课程"等都是实体型。

实体集：同一类型(同一实体型)的实体的集合，是实体型的实例集合。例如，某学校所有学生构成"学生"实体集

属性：**属性**是实体所具有的特性

码：**码**是能唯一标识一个元组的属性或属性组合。

E-R图：**E-R图**是实体-关系模型的图形化表示，是描述概念模型的标准工具

## 7.请用 E一R图画出此学校的概念模型。

学校中有若干系，每个系有若干班级和教研室，每个教研室有若干教师，其中有的教授和副教授每人各带若干研究生；每个班有若干学生，每个学生选修若干课程，每门课可由若干学生选修，某学生选修某门课程有一个成绩，

![1000039042.jpg](1000039042.jpg)

## 8.请用 E一R图画出此工厂产品、零件、材料、仓库的概念模型。

某工厂生产若干产品，每种产品由不同的零件组成，有的零件可用在不同的产品上。这些零件由不同的原材料制成，不同零件所用的材料可以相同。这些零件按所属的不同产品分别放在仓库中，原材料按照类别放在若干仓库中。

![1000039043.jpg](1000039043.jpg)

## 9.某医院的住院管理信息系统，请画出E-R图

科室：科室名，科室地址，科室电话

病房：病房号，床位号，科室名

医生：工作证号，姓名，职称，科室名，性别，年龄

住院病人：姓名，性别，身份证号

其中，一个科室可以有多名医生，有且仅有一个科室主任领导其他医生，一个医生只属于一个科室。一个病房只属于一个科室，一个科室有多个病房，一个病房只属于一个科室。一个医生可以负责治疗多位住院病人，一位住院病人可以同时由多名医生诊治，其中有一位为主治医生。

![1000039044.jpg](1000039044.jpg)

## 10.什么是数据库的逻辑结构设计？试述其设计步骤。

概念结构设计阶段设计好的基本 E一R图转换为关系模型。

1.将实体型和实体之间的联系转换为关系模式

2.确定关系模式的属性和码

3.，设计用户外模式（视图）

## 12.试用规范化理论中范式的概念分析第七题设计的关系模型中各个关系模式的候选码，他们属于第几范式？会产生什么异常？

第七题中设计的关系模型中的各个关系模式都只有一个码，且都是唯一的决定因素，也不存在传递依赖，所以属于BCNF，不会发生更新异常。

## 13.规范化理论对数据库设计的指导意义？

1. **消除数据冗余**：规范化通过分解关系模式，减少数据重复存储，节省存储空间。
2. **避免异常**：有效防止三种主要异常：
   - **插入异常**：无法添加某些数据除非先添加其他可能不相关的数据
   - **删除异常**：删除某数据时意外丢失其他有用信息
   - **更新异常**：同一数据在多处存储导致更新不一致
3. **增强数据一致性**：通过减少数据冗余，降低数据不一致的风险，提高数据质量。
4. **提供系统化设计方法**：从第一范式(1NF)到更高范式(BCNF/3NF/4NF/5NF)，提供了逐步改进数据库结构的路径。

## 14.数据库物理设计的内容和步骤

步骤：

1. 确定数据库的物理结构，主要指存取方法和存储结构
2. 对物理结构进行评价，重点是时间和空间效率
3. 存取方法
   1. B+树索引：某个属性或聚集函数经常需要被查询
   2. 哈希索引：主要用于等值连接中
   3. 聚簇方法：把属性上具有相同值的元组集中存放在连续的物理快中
4. 存取结构：
   1. 确定数据的存放位置：根据应用情况分开存放，提高系统性能
   2. 确定系统配置

内容：

使得数据库上运行的各种事务响应时间小，存储空间利用率高，事务吞吐量大。

## 16.什么是数据库的重组和重构？为什么要进行重组和重构？

重组 ：不修改原设计的逻辑和物理结构

重构：部分修改数据库的模式和内模式

为什么？

1. 数据库运行一段时间后，会出现大量缓存，数据不断更新，物理存储情况变坏，性能降低。
2. 原有的数据库设计不能满足新的需求

# 第九章 关系数据库存储管理

## 1.试分析每个数据库对象对应一个操作系统文件与整个数据库对应一个或若干个文件，这两种存储关系数据库的策略各有什么优缺点？

## **策略一：每个数据库对象对应一个操作系统文件**

### **优点：**

- **管理灵活性高**，可以针对单个表进行备份和恢复操作
- 可为不同表采用不同的存储参数
- **独立性强**，添加或修改表结构不会影响其他对象

### **缺点：**

- **文件数量庞大**，给文件系统带来管理压力
- **性能开销增加**，每个文件都有额外的打开、关闭和维护成本
- **备份复杂度高**，需要维护多个文件的一致性

## **策略二：整个数据库对应一个或若干个文件**

### **优点：**

- **备份恢复简便**，只需处理少量文件
- **内部存储优化空间大**，数据库可以自行安排最优的存储布局
- **事务处理更高效**，所有变更可在同一文件内组织

### **缺点：**

- **单点故障风险高**，文件损坏可能影响整个数据库
- **细粒度管理困难**，难以对单个表进行独立优化

## 2.关系表有哪些组织方式？各自的优缺点？

1. 堆存储
   1. 优点：可以存储在任何块中，没有顺序要求
   2. 缺点：数据难以组织
2. 顺序存储
   1. 记录按照某种顺序排列，可以实现随机存取
   2. 缺点：插入记录时，后面的数据都要后移
3. 多表聚簇存储
   1. 优点：不同表的记录也可以存放在同一个表中，对需要连接的查询实现预连接，加速查询速度
   2. 缺点：对于非连接查询来说，表的数据更多，降低了单表查询的速度
4. B+树存储
   与B+树索引的区别是：存储的叶节点是数据记录，不是索引项
   1. 优点：保持较高的查询效率并且降低数据维护开销
   2. 缺点：树不平衡之后，需要调整树的结构
5. 哈希存储
   1. 优点：利用哈希函数计算属性的哈希值，存放到对应的哈希表中，可以快速定位
   2. 缺点：哈希桶溢出后需要维护。

## 3.数据库索引机制的优点

1️⃣索引项的数量远远小于数据，搜索起来速度更快

2️⃣采用易于检索的数据结构，方便快速查找

3️⃣索引文件可以驻留在内存中，减少了I/O操作，也提高了查找速度

## 4.稠密索引和稀疏索引的优缺点？

## **稠密索引(Dense Index)**

### **优点:**

- **查询效率高**，可实现随机存取
- **支持任意关键字查询**，因为每条记录都有对应的索引项
- **不要求数据文件有序**，索引可以独立于原始数据排序

### **缺点:**

- **空间开销大**，索引大小与数据文件成正比
- **维护成本高**，每次记录变动都需更新索引
- **增删操作开销大**，需频繁重组索引结构
- **I/O负担重**，大型索引可能不适合全部加载到内存

## **稀疏索引(Sparse Index)**

### **优点:**

- **存储空间效率高**，只对每个数据块第一个记录建立索引项
- **维护成本低**，记录变动不一定需要更新索引
- **索引结构小**，更易于全部加载到内存中
- **适合大数据集**，可有效降低索引存储需求
- **插入删除效率高**，对索引结构影响小

### **缺点:**

- **查询性能次于稠密索引**，需要先定位到数据块再顺序查找
- **严格要求数据物理排序**，必须按索引键有序存储

## **应用选择**

- 当**存储空间受限**且数据量大时，稀疏索引更合适
- 当**查询性能是首要考虑**且有足够空间时，稠密索引更优
- **频繁更新的系统**可能更适合稀疏索引
- **频繁精确查询的系统**通常选择稠密索引
- 实际应用中常结合使用，如**多级索引结构**，平衡空间与性能需求
  --------------------------------------------------------

  ![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2029.png)

## 5.分别描述以下图是如何对Student表进行如下查询的

![图9.12](image%2030.png)

图9.12

![图9.13](image%2031.png)

图9.13

![图9.14](image%2032.png)

图9.14

![图9.16](image%2033.png)

图9.16

![图9.20](image%2034.png)

图9.20

![图9.23](image%2035.png)

图9.23

1️⃣查询学号为20180013的记录

图9.12稠密索引   自上向下逐个查找，找13次

图9.13稀疏索引    找到小于等于20180013的最小记录，然后根据指针到对应的存储块，在存储块中顺序查找

图9.14多级索引    `先找到二级的≤20180013的最大索引，再到一级索引找到≤20180013的最大索引，再到存储块中顺序查找`

图9.20B+树索引   20180013大于根20180008，向右查找，20180013大于20180012，再向右查找，找到20180013，再根据指针，找到对应记录

图9.23哈希索引    13%3=1，在一号桶内，顺序查找索引项，找到13，根据指针找到存储块，再在块内顺序查找

2️⃣查询学号为20180014的记录

图9.12稠密索引   自上向下逐个查找，找14次

图9.13稀疏索引   找到小于等于20180014的最小记录，即20180013，根据指针找存储块，在存储块中顺序查找

图9.14多级索引   same

图9.20B+树索引   same

图9.23哈希索引   same

3️⃣查询学号为20180016的记录

图9.12稠密索引   自上向下逐个查找，找15次，发现没有，结束

图9.13稀疏索引   找到小于等于20180016的最小记录，即20180015，根据指针在存储块中顺序查找，找不到

图9.14多级索引   same

图9.20B+树索引  same

图9.23哈希索引  same

4️⃣查询学号大于或等于20180009的记录

图9.12稠密索引   自上向下逐个查找，找9次到20180009，然后直到结束为止，这期间的7条记录都是

图9.13稀疏索引   找到≤20180009的最小记录，即20180009，顺序读取，再找下个索引块20180011，以此类推

图9.14多级索引   same

图9.20B+树索引  s ame

图9.23哈希索引   same

## 6.分别描述当用下列方式更新Student表中记录时，索引是如何维护的

1️⃣插入(20180016,张靖宁，女，2002-1-2，信息安全）记录

图9.12稠密索引

先从上向下逐个读取到≤20180016的20180015，然后在20180015索引项下面插入索引项20180016，再上对应的存储块插入数据，建立指针

图9.13稀疏索引

先从上向下逐个读取到≤20180016的20180015，找到存储块，发现有空位，不需要增加索引项，插入数据

图9.14多级索引

先从上向下逐个读取到≤20180016的20180013，再从上向下逐个读取到≤20180016的20180015，在20180015索引项下面插入索引项20180016，再上对应的存储块插入数据，建立指针

图9.16辅助索引

专业是信息安全，在辅助索引表中找到第二个信息安全，根据指针找到桶，先根据第一个位置的指针找到存储块，发现已满，在找到第二个位置，根据指针找到存储块，还有一个空位，插入

图9.20B+树索引

201800016大于根，向右，大于20180012，向右，大于2018015，但此时该节点达到最大充满度，将15与12,13,14分裂，在第二层的节点的12右侧插入15，新建节点，将15的右侧连接该节点，在节点内有两个索引数据15和16，此时该节点满足最小充满度，在记录表中插入数据，并与16连接

2️⃣删除学号为20180004的记录

3️⃣删除学号为20180005的记录

4️⃣将学号为20180008的记录修改为计算机科学与技术专业

# 第十章 关系查询处理和查询优化

## 1. 试述查询优化在关系数据库系统中的重要性和可能性。

### 重要性:

关系系统的查询优化既是**RDBMS实现的关键技术**又是**优点所在**。

用户不必考虑如何表达查询以获得较好的效率，系统会自动优化。

### 可能性：

**自动优化**: 优化器能够利用数据字典中的统计信息，如索引类型，用户难以获取这些信息

**动态变化：**根据数据库信息变化自动调整

**全面：**优化器可以从很多种计划中选择一个最优解，用户考虑方面较少

**易用性：**所有人不必掌握很好的优化技术就可以通过优化器获得高效的优化

## 2.假设关系R(A,B)和S(B,C,D)情况如下：R有20000个元组，S有1200个，一个块可以装下40个R的元组，30个S的元组，试着估算下列操作需要多少次磁盘块读写：

先计算R和S需要多少块： R:20000/40=500  S:1200/30=40

1️⃣R上无索引，select * from R;   `20000/40 = 500`

2️⃣R中A为主码，A有3层B+树索引，select * from R where A=10
`主码查询，结果唯一` 需读取三个索引块(3层)，读取一个数据块， `3+1=4`

3️⃣嵌套循环连接R⨝S
（内层次数：500*40） + （外层次数500）= 20,500次

4️⃣排序合并连接R⨝S，区分R与S在属性上有序和无序两种情况

1. 有序：

合并：500+40=540

1. 无序：需先排序，再合并

   1. 排序R：2 × 500 × log₂500 ≈ 9,000次
   2. 排序S：2 × 40 × log₂40 ≈ 480次
   3. 合并阶段：540次（同上）

   - 总磁盘读取次数 ≈ 9,000 + 480 + 540 = 10,020次

*从以上分析可以看出：*

1. *有索引的点查询效率最高*
2. *在连接操作中，如果数据已经排序，排序合并连接的效率远高于嵌套循环连接*
3. *如果数据未排序，排序合并连接的效率仍然优于嵌套循环连接，但差距减小*

## 3.对学生选课管理数据库

查询信息管理与信息系统专业学生选修的所有课程名称：

`SELECT Cname`

`FROM Student,Course,SC`

`WHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno AND Student.Smajor=’信息管理系统’;`

试画出关系代数表示的语法树，并用关系代数表达式优化算法对原始的树进行优化，画出优化后的标准语法树

![3.png](3.png)

## 4.对于数据库模式

Teacher(Tno,Tname,Tsex,Ttitle,Tbirthdate,Dno);

Department(Dno,Dname,Dcontact,Dtel,Director,SHno);

Work(Tno,Dno,Year,Salary);

假设Teacher的Tno属性，Department的Dno属性以及Work的Year属性上有B+树索引。请说明以下查询语句的较优的处理方法。

1️⃣SELECT * FROM Teachr WHERE Tsex=’女’

2️⃣SELECT * FROM Department WHERE Dno<30

3️⃣SELECT * FROM Work WHERE Year <> 2000

4️⃣SELECT * FROM Work WHERE Year >2000 AND Salary < 5000

5️⃣SELECT * FROM Work WHERE Year < 2000 OR Salary < 5000

![4.png](4.png)

## 5.对于第4题的数据库模式，有如下查询

SELECT Tname

FROM Teacher ,Department,Work

WHERE Teacher.Tno = Work.Tno AND Department.Dno = Work.Dno

AND Department.Dname = ‘计算机系’ AND Salary > 5000

画出语法树，关系代数标识的语法树，并对关系代数语法树进行优化。画出优化后的语法树

![5.png](5.png)

## 6.RDBMS查询优化的一般准则

1. 选择运算应尽可能先做
2. 把投影运算和选择运算同时进行:
3. 把投影同其前或其后的双目运算结合起来执行:
4. 把某些选择同在它前面要执行的笛卡儿积结合起来成为一个连接运算;
5. 找出公共子表达式;
6. 选取合适的连接算法。

## 7.RDBMS查询优化的一般步骤

1. 把查询转换成语法树。
2. 把原始的语法树转换成优化的形式。
3. 选择低层的存取路径。
4. 生成查询计划，选择代价最小的。

# 第十一章 数据库恢复技术

## 1.事务的概念以及事务的四个特性。数据库恢复技术能保证事务的那些特性？

事务是**用户定义的**一个数据库操作序列，是一个**不可分割**的工作单元。

ACID:

A原子性：事务中包括的操作要么都做，要么都不做。

C一致性： 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。也就是数据库中只包含成功提交的事务的结果。

I隔离性： 一个事务的执行不能被其他事务干扰。即一个事务内部的操作对其他并发事务是隔离的，互不干扰。

D持续性： 待续性也称为永久性，指一个事务一旦提交，对数据库中的改变是永久的。接下来的其他操作或故障不应该对其执行结果有任何影响。
恢复技术能保证事务的原子性、持久性。

## 2.为什么事务非正常结束时会影响数据库数据的正确性？举例

数据库系统运行中发生故障，事务被中断，部分修改有一部分已写入物理数据库，这时数据库就处于不一致性状态。

如：银行转账包含两个操作，A的账户减少1000元，B的账户增加1000元，A的钱减少之后事务中断，B的钱却没有增加。

## 3.登记日志文件时为什么必须先写日志文件，后写数据库？

有可能在写日志和修改数据库两个操作之间发生故障，只完成了一个。

若先修改了数据库却没有日志记录，则无法恢复这个修改。

若先写日志，则没有修改数据库，不会影响数据库的正确性。

## 4&&5.对于这个日志记录

| 序号 | 日志          |
| ---- | ------------- |
| 1    | T1:开始       |
| 2    | T1：写A，A=10 |
| 3    | T2:开始       |
| 4    | T2：写B,B=9   |
| 5    | T1:写C,C=11   |
| 6    | T1:提交       |
| 7    | T2:写C,C=13   |
| 8    | T3:开始       |
| 9    | T3:写A,A=8    |
| 10   | T2:回滚       |
| 11   | T3:写B,B=7    |
| 12   | T4:开始       |
| 13   | T3:提交       |
| 14   | T4:写C,C=12   |

1️⃣14之后，T1和T3已经提交，需重做，T4还未提交，要回滚

2️⃣10之后，T1已经提交，需重做，T3未提交，需回滚，

3️⃣9之后，T1需重做，T2,T3需回滚

4️⃣7之后，T1重做，T2回滚

---

---

---

5.假设开始时A,B,C都为0写出恢复后的值

1️⃣14之后，A=8,B=7,C=11,

2️⃣12之后，A = 10,B = 0,C = 11;

3️⃣10之后，A = 10,B = O,C = 11;

4️⃣9之后，A = 10,B = O,C = 11 ;

5️⃣7之后，A = 10,B = O,C = 11;

6️⃣5之后，A= O,B = O,C = 0 。

## 6.针对不同故障类型（事务，系统，介质）给出恢复的策略和方法

`小提示：事务处理技术主要包括数据库恢复技术和并发控制技术。`

`事务是数据库恢复和并发控制的基本单位。`

1️⃣事务故障的恢复：

(1)从后向前扫描日志文件，查找该事务的更新操作；
(2) 对该事务的更新操作回滚，将日志记录中更新前的状态写入数据库；
(3) 继续反向扫描日志文件，做同样处理；
(4) 直至读到此事务的开始标记，恢复完成。

2️⃣系统故障的恢复：

`系统故障两个原因：①未完成的事务已经写入数据库②已经提交的数据在缓冲区还未写入数据库`

因此需要做的就是回滚未完成的事务，重做已提交的事务

(1)正向扫描日志文件，找出在发生前已经提交的事务队列( REDO 队列）和未完成的事务队列(UNDO 队列） 。
(2) 对撤消队列中的各个事务进行UNOO 处理。
(3) 对重做队列中的各个事务进行REOO 处理。

3️⃣介质故障的恢复：

`介质故障是最严重的一种故障`

重装数据库，然后重做已完成的事务。

(l) DBA 装入最新的数据库后备副本，使数据库恢复到转储时的一致性状态；

(2) DBA 装入转储结束时刻的日志文件副本；

(3) DBA 启动系统恢复命令，重做已完成的事务。

## 7.什么是检查点记录？包括什么内容？

检查点记录是一类新的日志记录

包括：

(1)建立检查点时刻所有正在执行的事务清单。

(2) 这些事务的最新的日志记录的地址。

## 8.具有检查点的恢复技术有什么优点？举例

利用日志技术进行数据库恢复时，需要检查所有日志记录。

克服了①耗时间

②需要重做已完成的事务，重复操作

`例子：某事务T1 的更新操作实际上已经写到数据库中了，进行恢复时没有必要再REDO 处理`

## 9.使用检查点方法进行恢复的步骤

(1)从重新开始文件中找检查点记录在日志文件中的地址

(2) 由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE- LIST 。把ACTIVE— LIST 暂时放人UNDO- LIST 队列， REOO 队列暂为空。`正在执行的都暂时放入UNDO队列， 已经执行完毕的不用管`

3)从检查点开始正向扫描日志文件：
如有新开始的事务，暂时放入UNDO- UST 队列；

如有提交的事务，暂时放入REDO-LIST

4)对UNDO队列执行回滚，对REDO队列进行重做

## 10.什么是数据库镜像？有什么用途？

自动把整个数据库或者其中的部分关键数据复制到另一个磁盘上，同步更新。

用途：①数据库恢复，介质出现故障，利用镜像磁盘恢复数据

②实现并发使用。某数据被加上排他锁之后，其他用户可以读镜像数据库的数据，不必等待

## 数据库中为什么要有恢复子系统?它的功能是什么?

定期的建立检查点，保存数据库状态。

系统出现故障时，根据事务的不同状态，采取不同的恢复策略

## 数据库运行中可能产生的故障有哪几类?哪些故障影响事务的正常执行?哪些故障破坏数据库数据?

事务内部故障，系统故障，介质故障

**影响事务正常执行的故障**

1. **事务故障**
   通常影响单个事务的执行事务本身会被终止或回滚，但不会导致整个系统崩溃
2. **系统故障**
   影响所有正在执行的事务，可能导致内存中的数据丢失，但磁盘上的数据通常不受影响

**破坏数据库数据的故障**

**介质故障**

磁盘损坏…

## 数据库转储的意义是什么?试比较各种数据转储方法。

数据库中不正确的数据可以根据系统中的冗余数据来实现，
冗余数据的常用技术是 数据转储和 登记日志文件

定期地将数据库复制到其他介质上保存起来的过程。当数据库遭到破坏后可以将后备副本重新装入，将数据库恢复到转储时的状态。

静态转储:在系统中无运行事务时进行的转储操作，但过程中不允许新的事务，影响可用性

动态转储：不用等待正在运行的用户事务结束，也不会影响新事务的运行，需要日志文件的支持。

转储还分为海量转储；每次转储所有的

和增量转储：每次只转储变动的

# 第十二章 并发控制

## 1.在数据库中为什么要并发控制？并发控制技术能保证事务的哪些特性？

数据库是共享资源，通常有多个事务同时在运行，存在多个事务同时读取或修改同一数据，会破坏数据库的一致性。

保证数据库的一致性和隔离性。

## 2.并发操作可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？

### 丢失修改：

两个事务同时对一个数据进行修改，最后一个修改的会覆盖第一个，第一个的修改丢失

### 脏读:

T1先对数据修改，然后写入磁盘，T2读到修改后的数据，然后T1又回滚事务，T2读的不是最终的值。

### 不可重复读:UPDATE

T1第一次读值之后，T2对值进行修改，T1再次读值与第一次不一样。

### 幻读:DELETE,INSERT

DELETE:T1读完数据，T2删除某些记录，T1再次读，某些记录消失了

INSERT:T1读完数据，T2插入某些记录，T1再次读，某些记录多出来了

### 并发主要控制技术：

封锁方法(main)，时间戳方法，乐观控制方法和多版本并发控制方法。

## 3.事务的隔离级别都有哪些？事务隔离级别与数据一致性的关系是什么？

**级别由低到高分别是：   都避免丢失修改**

**读未提交 ：**     允许一个事务可以读取另一个未提交事务正在修改的数据       **`出现脏读、不可重复读和幻读的情形**`

**读已提交：**      只允许一个事务读其他事务已提交的数据     可以避免脏读，`不能保证可重复读和不幻读`

**可重复读：**      一个事务开始读取数据后，其他事务就不能再对该数据执行UPDATE操作了。  避免脏读和不可重复读，`不能保证不幻读`因为只是禁止了UPDATE操作

**可串行化** **：**     最高的事务隔离级别       `执行顺序是可串行化的，可以避免丢失修改、脏读、不可重复读和幻读`

![事务隔离级别与数据不一致性的关系](image%2036.png)

事务隔离级别与数据不一致性的关系

## 4.什么是封锁？基本的封锁类型有几种？试述它们的含义。

封锁就是事务T 在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。
加锁后事务T 就对该数据对象有了一定的控制，在事务T 释放它的锁之前，其他的事务不能更新或读取此数据对象。

基本的封锁类型有两种： 排他锁（简称X 锁）和共享锁（简称S 锁） 。

| T1          | **T2** | T2          |
| ----------- | ------------ | ----------- |
| T1          | **X**  | **S** |
| **X** | **N**  | **N** |
| **S** | **N**  | **Y** |

`只能在S上加S锁，有X锁什么也不能加`

排他锁又称  写锁。若T对A上了X锁，则只允许T读取和修改A，其他事务都不能对A加锁，直到T释放。

共享锁又称 读锁。若T对A上了X锁，则只允许T读取A，其他事务也只能对A加S锁，不可加X锁，在T释放S之前不能对A修改。

## 5.如何用封锁机制保证数据的一致性？

### 一级封锁协议：

在修改数据前必须先加X锁，直到事务COMMIT或ROLLBACK才释放。   防止丢失修改✅`并保证事务可恢复`
仅读数据则不加锁，`不可保证重复读和不脏读`

### 二级封锁协议：

| **T1**           | **T2**         |
| ---------------------- | -------------------- |
| **① XLOCK C**   |                      |
| **R(C)=100**     |                      |
| **C=C*2**        |                      |
| **W(C)=200**     |                      |
| **②**           | **SLOCK C**    |
|                        | **等待**       |
| **③ROLLBACK**   | **等待**       |
| **(C恢复为100)** | **等待**       |
| **UNLOCK C**     | **等待**       |
| **④**           | **获得SLOCKC** |
|                        | **R(C)=100**   |
| **⑤**           | **COMMIT C**   |
|                        | **UNLOCK C**   |

在1级基础上，读取数据之前不许先加S锁，读完可以释放S锁。  防止丢失修改，

读需要加S锁，由于X锁上不可加S，则需等待，T1回滚后T2才执行。

`进一步防止了脏读`✅

防止丢失修改✅

### 三级封锁协议：

在一级的基础上，事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放

| **T1**           | **T2**          |
| ---------------------- | --------------------- |
| **①  SLOCK A** |                       |
| **SLOCK B**      |                       |
| **R(A)=50**      |                       |
| **R(B)=100**     |                       |
| **A+B=150**      |                       |
| **②**           | **XLOCK B**     |
|                        | **等待**        |
| **③  R(A)=50** | **等待**        |
| **R(B)=100**     | **等待**        |
| **A+B=150**      | **等待**        |
| **COMMIT**       | **等待**        |
| **UNLOCK A**     | **等待**        |
| **UNLOCK B**     | **等待**        |
| **④**           | **获得XLOCK B** |
|                        | **R(B)=100**    |
|                        | **B=B*2**       |
| **⑤**           | **W(B)=200**    |
|                        | **COMMIT**      |
|                        | **UNLOCK B**    |

由于事务结束才释放，在未完成第二次验证前，S锁都不释放，T2无法对其加X锁进行修改，

`进一步避免了不可重复读`✅

脏读✅

防止丢失修改✅

## 6.什么是活锁？试述活锁的产生原因和解决方法。

T2陷入等待之中，一直被抢夺资源，有可能永远等待

`该等待事务等待时间太长，似乎被锁住了，实际上可能被激活`

| **T1**       | **T2**     | **T3**     | **T4**     |
| ------------------ | ---------------- | ---------------- | ---------------- |
| **LOCK R**   | **•**     |                  |                  |
| **•**       |                  |                  |                  |
| **•**       | **•**     |                  |                  |
| **•**       |                  |                  |                  |
| **•**       | **•**     |                  |                  |
| **•**       |                  |                  |                  |
| **•**       |                  |                  |                  |
| **•**       | **LOCK R** |                  |                  |
| **•**       | **等待**   | **LOCK R** |                  |
| **•**       | **等待**   | **•**     | **LOCK R** |
| **UNLOCK R** | **等待**   | **•**     | **等待**   |
|                    | **等待**   | **LOCK R** | **等待**   |
| **•**       | **等待**   | **•**     | **等待**   |
| **•**       | **等待**   | **UNLOCK** | **等待**   |
| **•**       | **等待**   | **•**     | **LOCK R** |
|                    | **等待**   | **•**     | **•**     |
| **•**       |                  |                  |                  |

活锁产生的原因： 当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务无限
期等待某个封锁，从而导致活锁。

避免活锁的简单方法是采用**先来先服务**的策略。

## 7.什么是死锁？请给出预防死锁的若干方法。

互相等待对方的资源，产生环，事务永远不能结束，形成死锁。

防止死锁的发生：破坏产生死锁的条件。

1. 一次封锁法：事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。
2. 顺序封锁法： 预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。

## 8.请给出检测死锁发生的一种方法，当发生死锁后如何解除死锁？

### 检测方法：

1️⃣超时法

事务等待时间超过了规定，认为发生了死锁

局限：

1. 误判死锁
2. 时限设置的太长，死锁不能及时发现

2️⃣事务等待图法

动态的反应事务的等待情况，若图中存在回路，则出现了死锁。

### 如何解除？

选择一个处理死锁代价最小的事务，将其撤销，并释放它持有的所有锁。

## 9.什么样的并发调度是正确的调度？

可串行化的调度是正确的调度。

多个事务的并发执行结果  与  按某次序串行地执行时的**结果相同**——称这种调度策略为**可串行化的调度**。

## 10.设T1,T2,T3是如下的三个事务，设A 的初值为0 。

T1:A:=A+2;

T2:A: =A* 2;

T3 :A: =A *A ; (A ←$A^2$）

1️⃣若这三个事务允许并行执行，则有多少可能的正确结果，请一一列举出来

T1 T2 T3 →16

T1 T3 T2 →8

T2 T1 T3→4

T2 T3 T1→2

T3 T1 T2→4

T3 T2 T1→2

2️⃣请给出一个可串行化的调度，并给出执行结果

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2037.png)

3️⃣请给出一个非串行化的调度， 并给出执行结果。

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2038.png)

4️⃣若这三个事务都遵守两段锁协议， 请给出一个不产生死锁的可串行化调度

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2039.png)

5️⃣若这三个事务都遵守两段锁协议，请给出一个产生死锁的调度。

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2040.png)

## 11.有三个事务的一个调度R3(B)R1(A)W3(B)R2(B)R2(A)W2(B)R1(B)W1(A),该调度是冲突可串行化的调度吗？ 为什么？

冲突可串行化定义：保证冲突操作次序不变情况下，交换操作得到另一个调度，则是冲突可串行的。

冲突可串行→可串行化          可串行化-\→冲突可串行

R与R不冲突，`R与W,W与W都冲突`

SC1= R3(B)W3(B)R2(B)R2(A)W2(B)R1(A)R1(B)W1(A)

是串行的，而且两次交换都是基于不冲突操作的，是冲突可串行化的调度。

## 12.试证明，若并发事务遵守两段锁协议，则对这些事务的并发调度是可串行化的。

遵守两段锁协议，则一定是冲突可串行化的，先申请再释放，冲突操作没有交换，

又由于冲突可串行化是可串行化的充分条件，则成立。

## 13.举例说明，对并发事务的一个调度是可串行化的，而这些并发事务不一定遵守两段

锁协议。

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2041.png)

## 14.考虑如下的调度，说明这些调度集合之间的包含关系。

1️⃣正确的调度

2️⃣可串行化的调度

3️⃣遵循两阶段封锁的调度

4️⃣串行调度

关系：

3️⃣遵循两阶段封锁的调度∈1️⃣正确的调度==2️⃣可串行化的调度

4️⃣串行调度∈1️⃣正确的调度

## 15.考虑T1和T2 两个事务。

| T1     | T2     |
| ------ | ------ |
| R(A);  | R(B);  |
| R(B);  | R(A);  |
| B=A+B; | A=A+B; |
| W(B)   | W(A)   |

1️⃣改写T1和T2 ，增加加锁操作和解锁操作， 遵循两阶段封锁协议。

2️⃣说明T1和T2的执行是否会引起死锁，给出T1和T2的一个调度说明之。

| 1️⃣    |          |
| -------- | -------- |
| T1       | T2       |
| SLock A  | SLock B  |
| R(A);    | R(B)     |
| XLock B  | XLock A  |
| R(B)     | R(A)     |
| B=A+B    | A=A+B    |
| W(B)     | W(A)     |
| Unlock A | Unlock B |
| Unlock B | Unlock A |

| 2️⃣   |          |
| ------- | -------- |
| T1      | T2       |
| SLock A |          |
| R(A)    |          |
|         | SLock B  |
|         | R(B)     |
| XLock B |          |
|         | XLock  A |

## 16.为什么要引入意向锁？意向锁的含义？

由于多粒度封锁包含显式封锁和隐式封锁，显式封锁直接对数据对象上锁，隐式封锁是由于父节点被加了锁。

数据库系统要检查上级节点和下级节点，效率很低。引入了意向锁，无序逐个检查下一级节点

意向锁的含义是：

对任一结点加锁，必须先对它的上层结点加意向锁。

对一个节点加意向锁，说明该节点后裔节点正在被加锁。

## 17.试述常用的意向锁： IS 锁、IX 锁、SIX 锁，给出这些锁的相容矩阵。

IS:对一个数据对象加IS锁，表示至少对其一个子节点加S锁

IX: 对一个数据对象加IX锁，表示至少对其一个子节点加X锁

SIX锁：先对该对象加S锁，在加IX锁。SIX=S+IX    `表示要读整个表，同时会更新个别元组。`

![Untitled]({{site.baseurl}}/img/in-post/2025-03-12-数据库系统概论/image%2042.png)
